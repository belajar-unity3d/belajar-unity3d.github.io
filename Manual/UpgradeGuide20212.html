<!doctype html>
<html lang="en" class="no-js">
 <head> 
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> 
  <script type="text/javascript" src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" charset="UTF-8" data-domain-script="6e91be4c-3145-4ea2-aa64-89d716064836"></script> 
  <script type="text/javascript">
					function OptanonWrapper() { }
				</script> 
  <script>var offline=false;if(!offline){(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);  })(window,document,'script','dataLayer','GTM-K8K24X8');}</script> 
  <link href="https://fonts.googleapis.com/css?family=Roboto&amp;display=swap" rel="stylesheet"> 
  <meta charset="utf-8"> 
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <title>Unity - Manual: Peningkatan ke Unity 2021.2</title> 
  <meta property="og:image" content="https://unity3d.com/files/images/ogimg.jpg"> 
  <meta name="author" content="Unity Technologies"> 
  <link rel="shortcut icon" href="https://unity.com/themes/contrib/unity_base/images/favicons/favicon.ico"> 
  <link rel="icon" type="image/png" href="../StaticFilesManual/images/favicons/favicon.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../StaticFilesManual/images/favicons/apple-touch-icon-152x152.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../StaticFilesManual/images/favicons/apple-touch-icon-144x144.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="../StaticFilesManual/images/favicons/apple-touch-icon-120x120.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../StaticFilesManual/images/favicons/apple-touch-icon-114x114.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../StaticFilesManual/images/favicons/apple-touch-icon-72x72.png"> 
  <link rel="apple-touch-icon-precomposed" href="../StaticFilesManual/images/favicons/apple-touch-icon.png"> 
  <meta name="msapplication-TileColor" content="#222c37"> 
  <meta name="msapplication-TileImage" content="../StaticFilesManual/images/favicons/tileicon-144x144.png"> 
  <script type="text/javascript" src="https://docs.unity3d.com/StaticFilesConfig/UnityVersionsInfo.js"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/jquery.js?ts=20220404"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/core.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/toc.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/global_toc.js?ts=20220404"></script> 
  <link rel="stylesheet" type="text/css" href="../StaticFilesManual/css/core.css?ts=20220404"> 
  <link rel="stylesheet" href="../StaticFilesManual/css/prism.css"> 
  <script src="../StaticFilesManual/js/prism.js"></script> 
  <script src="/StaticFilesConfig/feedback/feedback.js"></script> 
  <script src="../StaticFilesManual/js/jquery.sidebar.min.js"></script> 
  <link rel="stylesheet" href="../StaticFilesManual/css/mobileoptimisation.css"> 
  <script src="../StaticFilesManual/js/mobileoptimisation.js"></script> 
 </head> 
 <body> 
  <noscript> 
   <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K8K24X8" height="0" width="0" style="display:none;visibility:hidden"></iframe> 
  </noscript> 
  <div id="DocsAnalyticsData" data-area="none" data-pagetype="manual"></div> 
  <div class="header-wrapper"> 
   <div id="header" class="header"> 
    <div class="content"> 
     <div class="spacer"> 
      <div class="menu"> 
       <div id="nav-open" for="nav-input"> 
        <span></span> 
       </div> 
       <div class="logo"></div> 
       <div class="search-form"> 
        <form action="30_search.html" method="get" class="apisearch"> 
         <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
         <input type="submit" class="submit"> 
        </form> 
       </div> 
       <ul> 
        <li><a href="../Manual/index.html" class="selected">Manual</a></li> 
        <li><a href="../ScriptReference/index.html">API documentation</a></li> 
       </ul> 
      </div> 
     </div> 
     <div class="more"> 
      <div class="filler"></div> 
      <ul> 
       <li></li> 
      </ul> 
     </div> 
    </div> 
   </div> 
   <div class="toolbar"> 
    <div class="content"> 
    </div> 
   </div> 
   <div class="mobileLogo"></div> 
  </div> 
  <div id="master-wrapper" class="master-wrapper clear"> 
   <div id="sidebar" class="sidebar"> 
    <div class="sidebar-wrap"> 
     <div class="content"> 
      <div class="sidebar-menu"> 
       <div class="toc" id="customScrollbar"> 
        <h2>Manual Unity</h2> 
        <div class="search-form sidebar-search-form"> 
         <form action="30_search.html" method="get" class="apisearch"> 
          <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
          <input type="submit" id="mobileSearchBtn" class="submit" value="Search"> 
         </form> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div id="content-wrap" class="content-wrap"> 
    <div class="content-block"> 
     <div class="content"> 
      <div class="section"> 
       <div class="breadcrumbs clear"> 
        <ul> 
         <li><a href="UnityManual.html"></a></li> 
         <li><a href="UnityOverview.html">Bekerja di Unity</a></li> 
         <li><a href="UpgradeGuides.html">Unity upgrade</a></li> 
         <li>Peningkatan ke Unity 2021.2</li> 
        </ul> 
       </div> 
       <div class="mb20"> 
        <div class="nextprev clear"> 
         <div class="icon tt left mr1" data-distance="-40|-30|top"> 
          <span class="prev"><a href="APIUpdater.html"></a></span> 
          <div class="tip">
            API Updater 
          </div> 
         </div> 
         <div class="icon tt right" data-distance="-40|-30|top"> 
          <span class="next"><a href="UpgradeGuide20211.html"></a></span> 
          <div class="tip">
            Peningkatan ke Unity 2021.1 
          </div> 
         </div> 
        </div> 
       </div> 
       <div id="_leavefeedback"></div> 
       <h1>Peningkatan ke Unity 2021.2</h1> 
       <!--BeginSwitchLink--> 
       <!--EndSwitchLink--> 
       <div class="clear"></div> 
       <p> <strong>Note</strong>: Ikuti saran di bagian ini dalam urutan rilis. Misalnya, jika Anda perlu meningkatkan proyek Anda dari 2018 ke 2020, baca panduan peningkatan 2019 untuk melihat apakah ada perubahan yang Anda perlukan sebelum Anda membaca panduan peningkatan 2020.</p> 
       <p>Daftar halaman ini berubah dalam versi Unity 2021.2 yang mungkin mempengaruhi proyek yang ada ketika Anda meng-upgrade dari versi 2021.1 beta ke 2021.2.</p> 
       <h2>Pencahayaan lingkungan: probe Ambient dan probe refleksi skybox sekarang secara otomatis dipanggang</h2> 
       <p>Unity's Progressive <strong><span class="tooltip"><strong>Lightmapper</strong><span class="tooltiptext">A tool in Unity that bakes lightmaps according to the arrangement of lights and geometry in your scene. <a class="tooltipMoreInfoLink" href="Lightmapping.html">More info</a><br><span class="tooltipGlossaryLink">See in <a class="tooltipMoreInfoLink" href="Glossary.html#Lightmapper">Glossary</a></span></span></span></strong> sekarang secara otomatis menghasilkan probe ambient dan <span class="tooltip"><strong>skybox</strong><span class="tooltiptext">Jenis khusus Bahan yang digunakan untuk mewakili langit. Biasanya enam sisi. <a href="class-Skybox.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a class="tooltipMoreInfoLink" href="Glossary.html#Skybox">Glossary</a></span></span></span> <span class="tooltip"><strong>reflection probe</strong><span class="tooltiptext">Komponen rendering yang menangkap pandangan bulat dari sekitarnya di semua arah, seperti kamera. Gambar yang ditangkap kemudian disimpan sebagai kubus yang dapat digunakan oleh benda dengan bahan reflektif. <a href="class-ReflectionProbe.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a class="tooltipMoreInfoLink" href="Glossary.html#ReflectionProbe">Glossary</a></span></span></span> untuk setiap <span class="tooltip"><strong>scene</strong><span class="tooltiptext">Adegan berisi lingkungan dan menu permainan Anda. Pikirkan setiap file Adegan unik sebagai tingkat yang unik. Di setiap Adegan, Anda menempatkan lingkungan, hambatan, dan dekorasi, pada dasarnya merancang dan membangun permainan Anda dalam potongan-potongan. <a href="CreatingScenes.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Scene">Glossary</a></span></span></span> secara default. Ini berarti bahwa adegan secara otomatis menerima pencahayaan lingkungan sesuai dengan pengaturan di tab <strong>Environment</strong> di panel pengaturan <strong>Lighting</strong>. Editor memperbarui probe ambient dan probe refleksi skybox setiap kali perubahan pencahayaan lingkungan, sampai Anda menghasilkan pencahayaan. Ketika Anda bake dengan kontrol <strong>Generate Lighting</strong>, Editor berhenti memperbarui probe, dan hanya memperbarui mereka lagi di bake berikutnya. Ketika Anda mengaktifkan opsi <strong>Auto Generate</strong>, Editor terus memperbarui probe setiap kali perubahan pencahayaan lingkungan. Jika Anda menghasilkan pencahayaan dan kemudian menghapus data pencahayaan ini dengan menghapus Aset Data Pencahayaan dari proyek, Editor secara otomatis menghasilkan probe ambient dan probe refleksi skybox lagi.</p> 
       <p>Ada satu situasi yang membutuhkan tindakan ketika Anda meningkatkan proyek. Ini adalah ketika Anda tidak ingin memiliki kontribusi pencahayaan Lingkungan dalam proyek yang juga:</p> 
       <ul> 
        <li>Tidak memiliki Aset Data Pencahayaan.</li> 
        <li>Tidak memiliki <strong>Auto Generate</strong> diaktifkan.</li> 
        <li>Memiliki kontribusi lingkungan yang ditetapkan ke warna selain hitam.</li> 
       </ul> 
       <p>Dalam situasi ini, arahkan ke <strong>Window</strong> &gt; <strong>Rendering</strong> &gt; <strong>Lighting Settings</strong> &gt; <strong>Environment</strong> dan menonaktifkan kontribusi lingkungan dari probe ambient yang dihasilkan secara otomatis dan probe refleksi skybox dengan membuat salah satu perubahan berikut:</p> 
       <ul> 
        <li>Opsi 1: Mengatur <strong>Intensity Multiplier</strong> ke 0.</li> 
        <li>Opsi 2: Gunakan <strong>Skybox Material</strong> hitam.</li> 
        <li>Opsi 3: Gunakan warna hitam dalam mode <strong>Color</strong> atau <strong>Gradient</strong> untuk <strong>Source</strong>.</li> 
       </ul> 
       <h2>Sistem Partikel Bidang Angkatan</h2> 
       <p>Sebelumnya, beberapa properti Lapangan Angkatan berperilaku berbeda pada tingkat bingkai yang berbeda (atau jika menggunakan Skala Waktu dalam pengaturan Manajer Waktu)</p> 
       <p><span class="tooltip"><strong>Particle System</strong><span class="tooltiptext">Komponen yang mensimulasikan entitas fluida seperti cairan, awan dan nyala dengan menghasilkan dan memikat sejumlah besar gambar 2D kecil di tempat kejadian. <a class="tooltipMoreInfoLink" href="class-ParticleSystem.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#particlesystem">Glossary</a></span></span></span> sekarang menggunakan tingkat bingkai referensi 30fps untuk berfungsi sebagai dasar untuk simulasi. Jika aplikasi Anda berjalan pada tingkat bingkai yang berbeda, pengaturan berikut mungkin berperilaku berbeda dibandingkan dengan versi Unity sebelumnya:</p> 
       <ul> 
        <li>Gravity</li> 
        <li>Rotation</li> 
        <li>Vector Fields</li> 
       </ul> 
       <p>Jika pengaturan ini dipengaruhi, menyesuaikan kekuatan daerah yang terkena untuk mendapatkan penampilan yang diinginkan.</p> 
       <h2>Sistem Partikel Mulai Delay + Tingkat emisi Jarak</h2> 
       <p>Sebelumnya, Tingkat emisi jarak jauh mengabaikan pengaturan Start Delay. Sekarang, jika pengaturan Start Delay ditentukan, penundaan awal emisi berbasis jarak.</p> 
       <p>Jika bidang ini sebelumnya ditetapkan, Anda mungkin perlu menyesuaikannya.</p> 
       <h2>BuildReport - PackedAssets</h2> 
       <p>PackedAssets.file telah ditandai usang tanpa penggantian langsung. Sebelumnya ini mengadakan integer menandakan id file atau indeks ke BuildReport.files Untuk melihat file BuildReport sekarang, gunakan PackedAssets.shortPath.</p> 
       <h2>Terrain API dari eksperimental (WIP)</h2> 
       <p>API <span class="tooltip"><strong>Terrain</strong><span class="tooltiptext">Pemandangan di tempat kejadian Anda. Terrain GameObject menambahkan pesawat datar besar untuk adegan Anda dan Anda dapat menggunakan jendela Inspektur Terrain untuk menciptakan lanskap rinci. <a class="tooltipMoreInfoLink" href="terrain-UsingTerrains.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Terrain">Glossary</a></span></span></span> eksperimental telah dipindahkan ke ruang nama yang tidak berpengalaman. Ada juga beberapa perubahan kecil lainnya ke API Terrain. Jika Anda menggunakan API Terrain eksperimental, gunakan API berikut bukan:</p> 
       <ul> 
        <li> <code>UnityEngine.TerrainTools</code>;</li> 
        <li> <code>UnityEditor.TerrainTools</code>;</li> 
        <li> <code>UnityEngine.TerrainUtils</code>;</li> 
       </ul> 
       <p>Berikut adalah daftar perubahan API lengkap:</p> 
       <ul> 
        <li>Dalam kebanyakan kasus, <code>UnityEngine.Experimental.TerrainAPI</code> dan <code>UnityEditor.Experimental.TerrainAPI</code> sekarang <code>UnityEngine.TerrainTools</code> dan <code>UnityEditor.TerrainTools</code>, masing-masing. Beberapa API runtime telah pindah ke ruang nama <code>UnityEngine.TerrainUtils</code> baru.</li> 
        <li><code>GetDesc()</code> dari kelas <code>TerrainPaintTool&lt;T&gt;</code> berganti nama menjadi <code>GetDescription()</code>.</li> 
        <li>Kelas <code>TerrainUtility</code> telah pindah dari <code>UnityEngine.Experimental.TerrainAPI</code> ke <code>UnityEngine.TerrainUtils</code>.</li> 
        <li>Kelas <code>TerrainUtility.TerrainMap</code> tidak lagi merupakan kelas dalam dan milik ruang nama <code>UnityEngine.TerrainUtils</code>.</li> 
        <li>Struktur <code>TerrainMap.TileCoord</code> tidak lagi dalam kelas <code>TerrainMap</code>, telah berganti nama menjadi <code>TerrainTileCoord</code>, dan sekarang juga merupakan bagian dari ruang nama <code>UnityEngine.TerrainUtils</code>.</li> 
        <li>The <code>UnityEditor.Experimental.TerrainAPI.BrushPreviewMode</code> enum telah berganti nama menjadi <code>TerrainBrushPreviewMode</code> dan pindah ke ruang nama <code>UnityEditor.TerrainTools</code>.</li> 
        <li>0 Artikel - 0,00 € Ini juga telah berganti nama menjadi <code>TerrainPaintUtilityEditor.BuiltinPaintMaterialPasses</code>.<code>TerrainPaintUtilityEditor</code> class and into the <code>UnityEditor.TerrainTools</code> namespace. It has also been renamed to <code>TerrainBuiltinPaintMaterialPasses</code>.</li> 
        <li>Tiga fungsi <code>ShowBrushGUI</code> dalam <code>IOnInspectorGUI</code> telah digabungkan menjadi satu fungsi dengan nilai parameter default bukan fungsi yang berlebihan.</li> 
        <li> <code>TerrainFilter</code> telah dihapus. Gunakan <code>System.Predicate&lt;Terrain&gt;</code> bukan.</li> 
       </ul> 
       <h2>Tekstur2D.Resize berganti nama menjadi Reinitialize</h2> 
       <p> <code>Texture2D.Resize</code> dan kelebihan bebannya telah berganti nama menjadi <code>Texture2D.Reinitialize</code>.</p> 
       <p>API Updater harus mengubah nama ini secara otomatis. Jika tidak, ubah penggunaan <code>Texture2D.Resize</code> ke <code>Texture2D.Reinitialize</code>.</p> 
       <h2>Perubahan Android</h2> 
       <p>Bagian besar dari pipa build Android sekarang inkremental dan Unity menghapus fitur-fitur berikut yang berada di pipa build sebelumnya:</p> 
       <ul> 
        <li>Unity tidak lagi menyalin aset proyek <span class="tooltip"><strong>Gradle</strong><span class="tooltiptext">Sistem build Android yang mengotomatiskan beberapa proses build. Otomasi ini berarti bahwa banyak kesalahan build umum cenderung terjadi. <a class="tooltipMoreInfoLink" href="android-gradle-overview.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Gradle">Glossary</a></span></span></span> yang terletak di <strong>Assets</strong> /<strong>Plugins</strong> /<strong>Android</strong> ke proyek Gradle. <strong>[res, assets]</strong> to the Gradle project. 
         <ul> 
          <li>Sebelumnya Anda dapat menempatkan sumber daya Gradle di folder ini dan Unity disalin mereka ke proyek Gradle. Anda sekarang harus menggunakan <a href="AndroidAARPlugins.html">AAR atau Androidlib plug-ins</a> untuk lulus sumber daya Gradle tambahan ke aplikasi.</li> 
          <li>Jika Anda menempatkan aset proyek di folder ini, Unity menunjukkan pesan kesalahan build.</li> 
         </ul> </li> 
        <li>Unity tidak lagi mengabaikan file dalam komentar <strong>GENERATED BY UNITY. REMOVE THIS COMMENT TO PREVENT OVERWRITING WHEN EXPORTING AGAIN</strong>. 
         <ul> 
          <li>Sebelumnya Unity tidak akan menulis file jika Anda menghapus komentar ini. Jika Anda tidak menghapus komentar, Unity selalu regenerasi build.gradle, manifest, dan file UnityPlayerActivity.</li> 
          <li>Jika Anda ingin perubahan Anda untuk bertahan menggunakan pipa build baru, gunakan template.</li> 
         </ul> </li> 
        <li>Ketika Anda mengekspor proyek Android, Unity tidak lagi membuat paket zip simbol. Simbol sekarang tersedia di direktori <strong>unityLibrary\symbols</strong> yang dapat Anda zip. Alasan perubahan ini adalah bahwa tidak semua file simbol tersedia ketika Anda mengekspor sebuah proyek; Gradle menghasilkan simbol <code>libil2cpp.so</code> ketika membangun aplikasi.</li> 
        <li>Mengubah bagaimana pemeriksaan Unity untuk melihat apakah obb kompatibel dengan <span class="tooltip"><strong>apk</strong><span class="tooltiptext">Format paket Android output oleh Unity. Sebuah APK secara otomatis digunakan untuk perangkat Anda ketika Anda memilih File &gt; Build &amp; Run. <a class="tooltipMoreInfoLink" href="android-BuildProcess.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#APK">Glossary</a></span></span></span>. Kedua apk dan obb sekarang memiliki file unity_obb_guid di dalamnya dan jika konten yang cocok antara mereka, Unity memperlakukan mereka sebagai kompatibel.</li> 
        <li>Untuk membangun kustom <span class="tooltip"><strong>scripts</strong><span class="tooltiptext">Sepotong kode yang memungkinkan Anda untuk membuat Komponen Anda sendiri, memicu peristiwa permainan, memodifikasi sifat komponen dari waktu ke waktu dan menanggapi input pengguna dengan cara apa pun yang Anda sukai. <a class="tooltipMoreInfoLink" href="CreatingAndUsingScripts.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Scripts">Glossary</a></span></span></span> yang menggunakan <a href="../ScriptReference/BuildOptions.PatchPackage.html">PatchPackage</a>, perhatikan bahwa <strong>Patch/Patch &amp; Run</strong> sekarang bekerja dengan semua jenis aset dan tidak memerlukan Build Script Only.</li> 
       </ul> 
       <h2>UI Toolkit - Default scaleMode untuk Gambar berubah</h2> 
       <p>Gambar default.scaleMode diubah dari ScaleAndCrop ke ScaleToFit.</p> 
       <p>Perilaku yang diharapkan untuk gambar adalah untuk mengukur ukuran elemen, sehingga kami mengubah nilai default dari Image.scaleMode ke ScaleToFit. Jika Anda tidak menimpa mode skala gambar, beberapa gambar yang dirajut mungkin mengecilkan ukuran elemen. Jika ScaleAndCrop adalah mode yang diharapkan untuk gambar Anda, Anda dapat menimpa gaya mereka dengan menambahkan nilai berikut dalam gaya inline file UXML Anda:</p> 
       <p><code>-unity-background-scale-mode: scale-and-crop;</code></p> 
       <p>Anda juga dapat membuat kelas gaya dengan override dan menerapkannya ke gambar yang membutuhkan ScaleAndCrop.</p> 
       <h2>Perubahan perilaku peningkatan mono</h2> 
       <p>The underlying C# runtime, Mono, telah ditingkatkan dalam versi terbaru. Ini termasuk banyak perbaikan dari versi hulu Mono, dan beberapa perubahan yang tidak masuk akal dalam perilaku.</p> 
       <ul> 
        <li> <code>Directory.GetFiles</code> tidak lagi dijamin untuk mengembalikan daftar yang diurutkan. 
         <ul> 
          <li>Sebelumnya, ini selalu mengembalikan daftar item yang diurutkan secara alfabet. Jika proyek Anda membutuhkan item untuk dikembalikan dalam urutan yang sama setiap kali, memilah daftar yang dikembalikan. Contoh: var file = <code>Directory.GetFiles(dir).OrderBy(f =&gt; f)</code>;</li> 
         </ul> </li> 
        <li> <code>Object.GetHashCode</code> sekarang kembali nilai yang berbeda dan tidak boleh diandalkan sebagai algoritma hashing deterministik antara sistem operasi. 
         <ul> 
          <li>Secara umum, Anda tidak boleh menggunakan hasil <code>GetHashCode</code> di luar proses saat ini, itu tidak men serialisasinya atau mengharapkannya sama dengan waktu berikutnya kode berjalan dalam proses baru. Unity merekomendasikan menggunakan algoritma hashing deterministik seperti MD5.</li> 
         </ul> </li> 
        <li>Beberapa perbaikan bug telah menghasilkan pengecualian baru yang dibuang. Selain itu, konten beberapa pesan pengecualian telah berubah. 
         <ul> 
          <li>Perilaku baru ini akan sangat terlihat dalam skenario pengujian otomatis dan mungkin memerlukan perubahan perilaku yang diharapkan jika tes parsing log untuk pesan pengecualian tertentu.</li> 
         </ul> </li> 
       </ul> 
       <h2>Kinerja Adaptif</h2> 
       <p>Versi 3.0 dari paket Performa Adaptif sekarang tersedia. Untuk informasi tentang cara meningkatkan versi 3.0, lihat .</p> 
       <h2>RenderTexture KedalamanStensilFormat</h2> 
       <p>Sebelumnya, jika Anda mengatur properti ke 32-bit, Anda bisa mendapatkan D24_S8 tergantung pada platform. Sekarang jika Anda mengaturnya ke 32-bit, Anda mendapatkan D32_S8 dengan 32-bit untuk komponen kedalaman jika format itu didukung pada platform saat ini. Namun, ini menggandakan penggunaan memori untuk <span class="tooltip"><strong>depth buffer</strong><span class="tooltiptext">Sebuah toko memori yang memegang kedalaman nilai z setiap pixel dalam gambar, di mana nilai z adalah kedalaman untuk setiap piksel yang diberikan dari pesawat proyeksi. <a href="class-RenderTexture.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#depthbuffer">Glossary</a></span></span></span>.</p> 
       <p>Properti baru mengembalikan format yang digunakan API grafis untuk membuat sumber daya dalam memori video. Anda juga dapat menggunakan properti ini untuk meminta format tertentu. Namun, tidak semua platform mendukung semua format stensil kedalaman. Ketika Anda mengatur properti <code>DepthStencilFormat</code> untuk format yang tidak didukung, Unity secara otomatis memilih format yang kompatibel yang memiliki jumlah bit yang sama atau lebih besar untuk komponen kedalaman dan stensil.</p> 
       <h3>Upgrading</h3> 
       <p>Aset RenderTexture sekarang serialisasi format stensil kedalaman yang Anda pilih. Jika Anda menggunakan API yang mengambil sejumlah bit bukan format, bit ini dipetakan ke format dan format itu serialisasi. Aset RenderTexture dari versi sebelumnya yang memiliki kedalaman yang ditetapkan ke lebih dari 16-bit secara otomatis ditingkatkan untuk menggunakan D24_S8.</p> 
       <p>Pada beberapa platform (misalnya Windows) yang menggunakan API grafis DirectX, hasil ini dalam format dengan sedikit kedalaman yang lebih sedikit karena backend grafis memilih format D32_S8 internal jika Anda mengatur bit&gt; 16. Untuk memastikan peningkatan konsisten di semua platform, D24_S8 digunakan pada semua platform untuk pengupgrade otomatis. Namun, ini mungkin memperkenalkan artefak visual dalam output render proyek Anda jika Anda memiliki aset RenderTexture dalam proyek Anda. Tinjau aset ini dan mengubah format stensil kedalaman ke D32_S8 bila diperlukan. Masalah berikut mungkin terjadi:</p> 
       <ul> 
        <li>Ukuran memori mungkin meningkat untuk RenderTextures yang Anda gunakan. Namun, memori yang dilaporkan sekarang benar.</li> 
        <li>Sekarang yang mengatur properti kedalaman ke 32-bit memberi Anda komponen kedalaman 32-bit, penggunaan memori meningkat. Untuk menghindari ini, atur bit ke 24 dan gunakan D24_S8 jika didukung di platform Anda.</li> 
        <li>Jika platform tidak mendukung D24_S8, Unity jatuh kembali ke format kompatibel D32_S8 secara default. Untuk mencegah ini, di jendela <span class="tooltip"><strong>Inspector</strong><span class="tooltiptext">Jendela Unity yang menampilkan informasi tentang Pengaturan GameObject yang dipilih saat ini, aset atau proyek, memungkinkan Anda untuk memeriksa dan mengedit nilai. <a class="tooltipMoreInfoLink" href="UsingTheInspector.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Inspector">Glossary</a></span></span></span>, menonaktifkan properti <a href="class-RenderTexture.html">Format yang kompatibel</a> pada aset. Jika Unity tidak mendukung format D32_S8 dan tidak dapat jatuh kembali, Anda melihat pesan kesalahan “RenderTexture. Membuat gagal: format kedalaman / stensil tidak didukung. Tidak ada format yang kompatibel pada platform ini atau fallback ini ke format yang kompatibel dinonaktifkan dalam inspektur impor. Dalam kebanyakan kasus, untuk memperbaiki masalah yang dapat Anda ubah pada <strong>Enable Compatible Format</strong>.</li> 
       </ul> 
       <h2>Format grafis DepthAuto, ShadowAuto dan Video Mobil</h2> 
       <p>Format grafis berikut sekarang telah diuraikan:</p> 
       <ul> 
        <li>DepthAuto</li> 
        <li>ShadowAuto</li> 
        <li>VideoAuto</li> 
       </ul> 
       <p>Format "Auto" ini tidak jelas tentang format yang tepat yang digunakan dan mungkin bervariasi oleh platform.</p> 
       <p>Langkah-langkah untuk menghapus penggunaan format yang ditentukan ini tergantung pada format dan penggunaan kasus.</p> 
       <h4>Untuk VideoAuto</h4> 
       <p>Untuk mendapatkan format video otomatis platform saat ini, gunakan <code>SystemInfo.GetGraphicsFormat(DefaultFormat.Video)</code>.</p> 
       <h4>Untuk KedalamanAuto /Shadow Auto digunakan untuk menunjukkan tekstur render secara mendalam.</h4> 
       <p>GrafikFormat API sering menggunakan DepthAuto atau ShadowAuto untuk membuat <span class="tooltip"><strong>render textures</strong><span class="tooltiptext">Jenis Tekstur khusus yang diciptakan dan diperbarui pada runtime. Untuk menggunakannya, pertama membuat Tekstur Render baru dan menunjuk salah satu Kamera Anda untuk membuatnya. Kemudian Anda dapat menggunakan Tekstur Render dalam Bahan seperti Tekstur biasa. <a class="tooltipMoreInfoLink" href="class-RenderTexture.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#RenderTexture">Glossary</a></span></span></span> dengan rendering secara mendalam, dan tidak ada buffer warna. Contoh kasus penggunaan ini adalah:</p> 
       <ul> 
        <li><code>renderTextureDescriptor.graphicsFormat = GraphicsFormat.ShadowAuto</code></li> 
        <li><code>RenderTexture.GetTemporary(width, height, bits, GraphicsFormat.ShadowAuto)</code></li> 
       </ul> 
       <p>Untuk menunjukkan rendering dalam warna (non-warna), gunakan GraphicsFormat. Tidak seperti format warna baru. <code>renderTextureDescriptor.graphicsFormat = GraphicsFormat.None;</code> </p> 
       <p>Jika Anda menggunakan ShadowAuto, atur bayanganSamplingMode RenderTextureDescriptor Anda ke ShadowSamplingMode.CompareDepths untuk mengaktifkan sampling mendalam pada tekstur kedalaman, dan mengubah kode untuk menggunakan overload yang mengambil RenderTextureDescriptor. <code>renderTextureDescriptor.shadowSamplingMode = ShadowSamplingMode.CompareDepths;</code> </p> 
       <h4>Untuk KedalamanAuto /Shadow Auto dalam situasi lain</h4> 
       <p>Dalam beberapa situasi format DepthAuto/ShadowAuto mewakili format kedalaman yang dipilih secara otomatis sesuai untuk platform saat ini. Untuk mengganti nilai yang telah ditentukan dalam kasus ini, gunakan <code>SystemInfo.GetGraphicsFormat(DefaultFormat.Depth/Shadow)</code> </p> 
       <h2>WebGL: Diperbarui Emscripten ke 2.0.19</h2> 
       <p>Target asm.js Linker yang tersedia untuk pengguna tingkat lanjut tidak lagi tersedia.</p> 
       <ul> 
        <li>Pada Unity 2021.2, kompilasi Emscripten yang mendasari digunakan oleh platform <span class="tooltip"><strong>WebGL</strong><span class="tooltiptext">Login API yang membuat grafis 2D dan 3D di browser web. Opsi build Unity WebGL memungkinkan Unity untuk mempublikasikan konten sebagai program JavaScript yang menggunakan teknologi HTML5 dan WebGL rendering API untuk menjalankan konten Unity di browser web. <a class="tooltipMoreInfoLink" href="webgl-gettingstarted.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a class="tooltipMoreInfoLink" href="Glossary.html#WebGL">Glossary</a></span></span></span> diperbarui ke versi 2.0.19. Ini meningkatkan format file objek kode asli, dan oleh karena itu membutuhkan mengompilkan semua plugin kode asli (plugin kode C / C++) dalam proyek. Jika Anda menggunakan plugin pihak ketiga dari Unity <span class="tooltip"><strong>Asset Store</strong><span class="tooltiptext">Sebuah perpustakaan yang berkembang dari aset gratis dan komersial yang diciptakan oleh Unity dan anggota komunitas. Menawarkan berbagai aset, dari tekstur, model dan animasi ke seluruh contoh proyek, tutorial dan ekstensi Editor. <a href="AssetStore.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#AssetStore">Glossary</a></span></span></span>, misalnya, ingatlah untuk meminta penulis untuk versi terbaru untuk Unity 2021.2.</li> 
        <li>Fungsi JavaScript runtime emscripten <code>Pointer_stringify()</code>is sekarang didepresikan. Sebagai gantinya, sebutkan fungsi <code>UTF8ToString()</code> untuk mengasah string C yang dikodekan UTF8 dari WebAssembly heap ke string JavaScript.</li> 
       </ul> 
       <h2>Progres GPU Dukungan dropped Lightmapper untuk perangkat OpenCL CPU</h2> 
       <p>Progresif GPU Lightmapper tidak lagi mendukung perangkat OpenCL CPU. Jika tidak ada perangkat GPU yang didukung ditemukan tetapi perangkat OpenCL CPU terdeteksi, pesan peringatan memberi tahu Anda bahwa perangkat digesek dan jatuh kembali ke Progressive CPU Lightmapper. Progresif CPU Lightmapper menawarkan kinerja yang lebih baik untuk perhitungan berbasis CPU <span class="tooltip"><strong>lightmaps</strong><span class="tooltiptext">Tekstur pra-render yang mengandung efek sumber cahaya pada objek statis di tempat kejadian. Lightmaps dilalui atas geometri adegan untuk menciptakan efek pencahayaan. <a class="tooltipMoreInfoLink" href="Lightmapping.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Lightmap">Glossary</a></span></span></span>. Perubahan perilaku ini akan terjadi secara otomatis dan peta lampu harus sebanding seperti yang diharapkan.</p> 
       <h2></h2> 
       <p>Ketika metode Unity panggilan <code>InitializeOnLoad</code> selama proses impor aset, pemuatan aset dapat gagal. Selama impor aset, database aset dalam state update dan Unity tidak dapat menentukan aset mana yang telah diimpor. Metode <code>InitializeOnLoad</code> tidak dapat memuat aset yang belum diimpor.</p> 
       <p>Untuk meningkatkan proses impor aset, callback <code>OnPostprocessAllAssets</code> telah ditingkatkan. Secara khusus, callback <code>OnPostprocessAllAssets</code>:</p> 
       <ul> 
        <li>Dapat melakukan initialisasi setelah reload domain, ketika database aset dijamin dalam keadaan siap.</li> 
        <li>Mengandung parameter <code>didDomainReload</code>, yang ditetapkan untuk benar jika domain telah diisi ulang.</li> 
        <li>Mendukung operasi aset. Ini termasuk pemuatan aset, yang berperilaku dengan cara yang sama dengan memuat aset melalui item menu.</li> 
        <li>Telah pindah dari loop impor database aset. Pengolahan callback ditunda sampai impor aset selesai.</li> 
       </ul> 
       <p>Pindahkan logika penginisialisasi domain yang memerlukan operasi aset ke callback <code>OnPostprocessAllAsset</code>; jangan melakukan operasi aset dalam metode <code>InitializeOnLoad</code>.</p> 
       <p>Contoh kode perubahan perilaku berikut menunjukkan bagaimana operasi aset sebelumnya ditunda.</p> 
       <p>Contoh 1:</p> 
       <pre><code>public class AssetPostprocessorTester1 : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
    {
        var assetPath = "Assets/hello.txt";

        if (File.Exists(assetPath))
        {
            var txtObj = AssetDatabase.LoadAssetAtPath&lt;TextAsset&gt;("Assets/hello.txt");
            AssetDatabase.DeleteAsset("Assets/hello.txt");

            if (txtObj == null)
                Debug.Log("New Behaviour: Asset object is unloaded");
            else
                Debug.Log("Old Behaviour: Asset is loaded for deleted asset!!");
        }
    }
}
</code></pre> 
       <p>Contoh 2:</p> 
       <pre><code> public class AssetPostprocessorTester2 : AssetPostprocessor
{
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
    {
        var assetPath = "Assets/SomeText.txt";
        if (!File.Exists(assetPath))
        {
            File.WriteAllText(assetPath, "hello world");

            AssetDatabase.ImportAsset(assetPath);
            var txtObj = AssetDatabase.LoadAssetAtPath&lt;TextAsset&gt;(assetPath);

            if (txtObj == null)
                Debug.Log("Old Behaviour: Asset hasn't been imported yet");
            else
                Debug.Log("New Behaviour: Asset is imported and loaded");
        }
    }
}
</code></pre> 
       <p>Contoh berikut memiliki varian <code>OnPostprocessAllAssets</code> baru dengan parameter <code>didDomainReload</code>:</p> 
       <pre><code>static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths, bool didDomainReload)
{
    if (didDomainReload)
        Debug.Log("Domain has been reloaded");
    else
        Debug.Log("Domain did not reload during import");
}
</code></pre> 
       <p>Semua reload domain sekarang diproses dalam database aset.</p> 
       <p> <code>OnPostprocessAllAssets</code> sekarang bekerja lebih baik dengan operasi aset, tetapi setiap pemrosesan dalam callback ini meningkatkan database aset menyegarkan dan waktu reload domain. Metode <code>InitializeOnLoad</code> juga menambah waktu reload domain. Ini adalah praktik terbaik untuk meminimalkan pemrosesan dalam panggilan ini untuk meningkatkan responsifitas Editor antara iterasi.</p> 
       <h2>Peningkatan sistem kata kunci Shader</h2> 
       <p>Sistem kata kunci <span class="tooltip"><strong>shader</strong><span class="tooltiptext">Program yang berjalan di GPU. <a class="tooltipMoreInfoLink" href="Shaders.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Shader">Glossary</a></span></span></span> sekarang memungkinkan hingga 65534 kata kunci lokal per naungan atau kolon dan 2<sup>32</sup>-2 kata kunci global per proyek. Semua kata kunci yang Anda deklarasikan dalam naungan atau kolon sekarang lokal ke naungan ini. Kata kunci yang Anda deklarasikan secara langsung dengan suffix lokal tidak dipengaruhi oleh negara kata kunci global.</p> 
       <p>Contoh:</p> 
       <p>A lulus dalam naungan menyatakan kata kunci berikut:</p> 
       <ul> 
        <li><code>#pragma shader_feature FOO BAR</code></li> 
        <li><code>#pragma shader_feature_local BOO BAZ</code></li> 
       </ul> 
       <p>Ketika menggunakan kata kunci FOO dan BAR ini diaktifkan jika mereka diaktifkan baik secara global atau pada materi. Kata kunci BOO dan BAZ hanya diaktifkan jika mereka diaktifkan pada materi.</p> 
       <h2>Unity mendukung .NET Standard 2.1 API</h2> 
       <p>Unity sekarang mendukung banyak API tambahan di . Perpustakaan kelas dasar NET, termasuk semua API di . NET Standard 2.1 API. Proyek Anda mungkin gagal untuk mengkompilasi jika kode Anda memiliki konflik dengan API baru.</p> 
       <p>Untuk menghindari kesalahan ketika Anda meng-upgrade proyek yang dibuat dalam versi Unity sebelumnya, periksa dan memperbarui kode Anda untuk memastikan bahwa tidak ada konflik dengan jenis dan metode yang sekarang tersedia di . Standar NET 2.1.</p> 
       <p>Sumber konflik termasuk berikut:</p> 
       <ul> 
        <li>ambiguous references</li> 
        <li>metode ekstensi</li> 
        <li>precompiled assemblies</li> 
       </ul> 
       <h4>Resolve referensi ambiguous</h4> 
       <p>Jika kode Anda menerapkan jenis atau metode dengan nama yang bertentangan dengan jenis atau metode yang. NET Standard 2.1 menambahkan, kode Anda gagal untuk dikompilasi. Nama konflik dapat menyebabkan kesalahan kompiler C# karena referensi yang ambigu.</p> 
       <p>Misalnya, jika Anda menambahkan jenis bernama <code>MyCompany.MyCode.Range</code> ke kode proyek Anda, ini mungkin bertentangan dengan jenis <code>System.Range</code> yang ada. Kode yang mengandung pernyataan <code>using System;</code> dan <code>using MyCompany;</code> gagal dikompilasi.</p> 
       <p>Untuk mencegah kesalahan, sepenuhnya menentukan namespace dalam kode C# untuk segala jenis yang memiliki nama konflik.</p> 
       <h4>Metode perpanjangan konflik penyelesaian</h4> 
       <p>Jika kode yang ada memiliki metode ekstensi yang. Standar NET 2.1 sekarang mengimplementasikan pada jenis secara langsung, Anda dapat memilih untuk mengubah nama metode ekstensi Anda atau untuk menggunakan metode yang diterapkan oleh perpustakaan kelas dasar.</p> 
       <p>Sebagai contoh, kode dalam proyek Anda mungkin menerapkan metode ekstensi bernama <code>CopyTo</code> pada tipe <code>ArraySegment</code>. Dalam Standar .NET 2.1, <code>ArraySegment</code> memiliki metode built-in <code>CopyTo</code>. Anda dapat memilih untuk mengubah nama metode ekstensi <code>CopyTo</code> Anda, atau menghilangkannya sepenuhnya dan menggunakan yang built-in.</p> 
       <h4>Perakitan konflik penyelesaian</h4> 
       <p>Jika proyek Anda menggunakan rakitan prekompiled (yaitu, plugin yang dikelola) yang menerapkan jenis dan metode yang sekarang bagian dari perpustakaan kelas dasar, kemudian menghapus rakitan ini dari proyek Anda dan menggunakan implementasi bawaan.</p> 
       <p>Misalnya, dalam versi Unity sebelumnya, Anda perlu menggunakan perakitan <code>System.Memory.dll</code> dari NuGet untuk mengakses tipe nilai <code>System.Span</code>. Sekarang, .NET Standard 2.1 menyediakan <code>System.Span</code> di perpustakaan kelas dasar. Jika Anda mencoba menggunakan plugin yang dikelola di Unity 2021.2, proyek gagal untuk membangun.<code>System.Memory.dll</code> managed plugin in Unity 2021.2, the project fails to build.</p> 
       <h2>Windows XP (32/64 bit)</h2> 
       <p>Microsoft telah menentukan plugin Windows XR dan sekarang mendukung fitur dan perangkat Windows Mixed Reality (WMR) melalui plugin OpenXR.</p> 
       <ul> 
        <li>Plugin Windows XR telah dihapus sebagai Unity 2021.2.</li> 
        <li>Ketika Anda membuka proyek yang ada di Unity 2021.2, proses pembaruan menghapus plugin Windows XR, jika ada.</li> 
        <li>Untuk terus menggunakan proyek untuk Windows Mixed Reality, Anda harus mengaktifkan plugin Unity OpenXR.</li> 
        <li>Tergantung pada fitur yang Anda gunakan, Anda juga harus menginstal plugin dukungan Microsoft Mixed Reality OpenXR dan mungkin alat tambahan dari Microsoft Mixed Reality Toolkit.</li> 
       </ul> 
       <p>Untuk meningkatkan ke plugin Unity OpenXR:</p> 
       <ol> 
        <li>Buka jendela <strong><span class="tooltip"><strong>Project Settings</strong><span class="tooltiptext">A broad collection of settings which allow you to configure how Physics, Audio, Networking, Graphics, Input and many other areas of your project behave. <a class="tooltipMoreInfoLink" href="comp-ManagerGroup.html">More info</a><br><span class="tooltipGlossaryLink">See in <a href="Glossary.html#ProjectSettings">Glossary</a></span></span></span></strong>.</li> 
        <li>Pada bagian <strong>XR <span class="tooltip"><strong>Plug-in</strong><span class="tooltiptext">A set of code created outside of Unity that creates functionality in Unity. There are two kinds of plug-ins you can use in Unity: Managed plug-ins (managed .NET assemblies created with tools like Visual Studio) and Native plug-ins (platform-specific native code libraries). <a class="tooltipMoreInfoLink" href="Plugins.html">More info</a><br><span class="tooltipGlossaryLink">See in <a href="Glossary.html#Plug-in">Glossary</a></span></span></span> Management</strong>, aktifkan <strong>OpenXR</strong> dalam daftar <strong>Plug-in Providers</strong>. Jika diperlukan, unduhan Unity dan instal plugin OpenXR.</li> 
       </ol> 
       <p>Setelah plugin OpenXR diaktifkan, Anda dapat menggunakan <strong>Mixed Reality Feature Tool</strong> yang disediakan oleh Microsoft untuk menginstal paket pendukung yang diperlukan.</p> 
       <p>Untuk menginstal atau memperbarui fitur WMR, alat, dan sampel:</p> 
       <ol> 
        <li>Unduh dan jalankan <a href="https://docs.microsoft.com/en-us/windows/mixed-reality/develop/unity/welcome-to-mr-feature-tool">Alat Fitur Realita Campuran</a>.</li> 
        <li>Pilih Proyek Unity untuk memperbarui dan klik Temukan Fitur.</li> 
        <li>Di bawah Dukungan Platform, pilih Mixed Reality OpenXR Plugin.</li> 
        <li>Pilih fitur tambahan yang ingin Anda tambahkan.</li> 
        <li>Klik Dapatkan fitur.</li> 
        <li>Klik Impor dan kemudian Banding untuk menyelesaikan proses.</li> 
        <li>Kembali ke bagian Manajemen Plug-in XR dari Pengaturan Proyek Unity Anda dan memungkinkan dan mengkonfigurasi fitur tambahan.</li> 
       </ol> 
       <p>Untuk informasi lebih lanjut tentang mengatur proyek Unity baru dan diperbarui untuk menggunakan Windows Mixed Reality, lihat <a href="https://docs.microsoft.com/en-us/windows/mixed-reality/develop/unity/xr-project-setup?tabs=openxr">Menyiapkan konfigurasi XR Anda</a> di situs dokumentasi Microsoft.</p> 
       <div id="_content"></div> 
       <div class="nextprev clear"> 
        <div class="icon tt left mr1" data-distance="-40|-30|top"> 
         <span class="prev"><a href="APIUpdater.html"></a></span> 
         <div class="tip">
           API Updater 
         </div> 
        </div> 
        <div class="icon tt right" data-distance="-40|-30|top"> 
         <span class="next"><a href="UpgradeGuide20211.html"></a></span> 
         <div class="tip">
           Peningkatan ke Unity 2021.1 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="footer-wrapper"> 
       <div class="footer clear"> 
        <div class="copy">
          © 2022 Unity Technologies. Tanggal Publikasi: 2022-04-04. 
        </div> 
        <div class="menu"> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div>  
 </body>
</html>
<!doctype html>
<html lang="en" class="no-js">
 <head> 
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> 
  <script type="text/javascript" src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" charset="UTF-8" data-domain-script="6e91be4c-3145-4ea2-aa64-89d716064836"></script> 
  <script type="text/javascript">
					function OptanonWrapper() { }
				</script> 
  <script>var offline=false;if(!offline){(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);  })(window,document,'script','dataLayer','GTM-K8K24X8');}</script> 
  <link href="https://fonts.googleapis.com/css?family=Roboto&amp;display=swap" rel="stylesheet"> 
  <meta charset="utf-8"> 
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <title>Unity - Manual: String dan teks</title> 
  <meta property="og:image" content="https://unity3d.com/files/images/ogimg.jpg"> 
  <meta name="author" content="Unity Technologies"> 
  <link rel="shortcut icon" href="https://unity.com/themes/contrib/unity_base/images/favicons/favicon.ico"> 
  <link rel="icon" type="image/png" href="../StaticFilesManual/images/favicons/favicon.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../StaticFilesManual/images/favicons/apple-touch-icon-152x152.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../StaticFilesManual/images/favicons/apple-touch-icon-144x144.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="../StaticFilesManual/images/favicons/apple-touch-icon-120x120.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../StaticFilesManual/images/favicons/apple-touch-icon-114x114.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../StaticFilesManual/images/favicons/apple-touch-icon-72x72.png"> 
  <link rel="apple-touch-icon-precomposed" href="../StaticFilesManual/images/favicons/apple-touch-icon.png"> 
  <meta name="msapplication-TileColor" content="#222c37"> 
  <meta name="msapplication-TileImage" content="../StaticFilesManual/images/favicons/tileicon-144x144.png"> 
  <script type="text/javascript" src="https://docs.unity3d.com/StaticFilesConfig/UnityVersionsInfo.js"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/jquery.js?ts=20220404"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/core.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/toc.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/global_toc.js?ts=20220404"></script> 
  <link rel="stylesheet" type="text/css" href="../StaticFilesManual/css/core.css?ts=20220404"> 
  <link rel="stylesheet" href="../StaticFilesManual/css/prism.css"> 
  <script src="../StaticFilesManual/js/prism.js"></script> 
  <script src="/StaticFilesConfig/feedback/feedback.js"></script> 
  <script src="../StaticFilesManual/js/jquery.sidebar.min.js"></script> 
  <link rel="stylesheet" href="../StaticFilesManual/css/mobileoptimisation.css"> 
  <script src="../StaticFilesManual/js/mobileoptimisation.js"></script> 
 </head> 
 <body> 
  <noscript> 
   <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K8K24X8" height="0" width="0" style="display:none;visibility:hidden"></iframe> 
  </noscript> 
  <div id="DocsAnalyticsData" data-area="core" data-pagetype="manual"></div> 
  <div class="header-wrapper"> 
   <div id="header" class="header"> 
    <div class="content"> 
     <div class="spacer"> 
      <div class="menu"> 
       <div id="nav-open" for="nav-input"> 
        <span></span> 
       </div> 
       <div class="logo"></div> 
       <div class="search-form"> 
        <form action="30_search.html" method="get" class="apisearch"> 
         <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
         <input type="submit" class="submit"> 
        </form> 
       </div> 
       <ul> 
        <li><a href="../Manual/index.html" class="selected">Manual</a></li> 
        <li><a href="../ScriptReference/index.html">API documentation</a></li> 
       </ul> 
      </div> 
     </div> 
     <div class="more"> 
      <div class="filler"></div> 
      <ul> 
       <li></li> 
      </ul> 
     </div> 
    </div> 
   </div> 
   <div class="toolbar"> 
    <div class="content"> 
    </div> 
   </div> 
   <div class="mobileLogo"></div> 
  </div> 
  <div id="master-wrapper" class="master-wrapper clear"> 
   <div id="sidebar" class="sidebar"> 
    <div class="sidebar-wrap"> 
     <div class="content"> 
      <div class="sidebar-menu"> 
       <div class="toc" id="customScrollbar"> 
        <h2>Manual Unity</h2> 
        <div class="search-form sidebar-search-form"> 
         <form action="30_search.html" method="get" class="apisearch"> 
          <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
          <input type="submit" id="mobileSearchBtn" class="submit" value="Search"> 
         </form> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div id="content-wrap" class="content-wrap"> 
    <div class="content-block"> 
     <div class="content"> 
      <div class="section"> 
       <div class="breadcrumbs clear"> 
        <ul> 
         <li><a href="UnityManual.html">Manual Pengguna Unity 2022.1 (beta)</a></li> 
         <li><a href="UnityOverview.html">Bekerja di Unity</a></li> 
         <li><a href="analysis.html">Analysis</a></li> 
         <li><a href="BestPracticeUnderstandingPerformanceInUnity.html">Memahami optimasi dalam Unity</a></li> 
         <li>String dan teks</li> 
        </ul> 
       </div> 
       <div class="mb20"> 
        <div class="nextprev clear"> 
         <div class="icon tt left mr1" data-distance="-40|-30|top"> 
          <span class="prev"><a href="BestPracticeUnderstandingPerformanceInUnity4.html"></a></span> 
          <div class="tip">
            Audit aset 
          </div> 
         </div> 
         <div class="icon tt right" data-distance="-40|-30|top"> 
          <span class="next"><a href="BestPracticeUnderstandingPerformanceInUnity6.html"></a></span> 
          <div class="tip">
            Folder Sumber Daya 
          </div> 
         </div> 
        </div> 
       </div> 
       <div id="_leavefeedback"></div> 
       <h1>String dan teks</h1> 
       <!--BeginSwitchLink--> 
       <!--EndSwitchLink--> 
       <div class="clear"></div> 
       <p>Penanganan string dan teks adalah sumber umum masalah kinerja dalam proyek Unity. Di C#, semua string adalah <span class="tooltip"><strong>immutable</strong><span class="tooltiptext">Anda tidak dapat mengubah isi paket immutable (read-only). Ini adalah kebalikan dari <strong>mutable</strong>. Kebanyakan paket tidak dapat diakses, termasuk paket yang diunduh dari registry paket atau melalui URL Git.<br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Immutable">Glossary</a></span></span></span>. Setiap manipulasi hasil string dalam alokasi string baru penuh. Ini relatif mahal, dan ringkasan string berulang dapat berkembang menjadi masalah kinerja ketika dilakukan pada string besar, pada set data besar, atau dalam loop ketat.</p> 
       <p>Selanjutnya, sebagai komputasi string N memerlukan alokasi string perantara N–1, kondensasi serial juga dapat menjadi penyebab utama dari tekanan memori yang dikelola.</p> 
       <p>Untuk kasus di mana string harus dikonsepkan dalam loop ketat atau selama setiap bingkai, gunakan StringBuilder untuk melakukan operasi concatenation yang sebenarnya. Contoh StringBuilder juga dapat digunakan kembali untuk lebih meminimalkan alokasi memori yang tidak perlu.</p> 
       <p>Microsoft mempertahankan daftar praktik terbaik untuk bekerja dengan string di C #, yang dapat ditemukan di sini di situs MSDN: <a href="https://msdn.microsoft.com/en-us/library/dd465121(v=vs.110).aspx">msdn.microsoft.com</a>.</p> 
       <h2>Perbandingan lokal dan ordinal</h2> 
       <p>Salah satu masalah kinerja inti sering ditemukan dalam kode terkait string adalah penggunaan yang tidak diinginkan dari API string default. API ini dibangun untuk aplikasi bisnis, dan mencoba menangani string penanganan dari berbagai aturan budaya dan linguistik berkaitan dengan karakter yang ditemukan dalam teks.</p> 
       <p>Misalnya, kode contoh berikut kembali benar ketika berjalan di bawah penduduk lokal AS-Inggris, tetapi kembali palsu bagi banyak penduduk Eropa.</p> 
       <p> <strong>Note</strong>: Sebagai Unity 5.3 dan 5.4, runtimes skrip Unity selalu berjalan di bawah warga negara AS (en-US):</p> 
       <pre><code>    String.Equals("encyclopedia", “encyclopædia”);
</code></pre> 
       <p>Untuk sebagian besar proyek Unity, ini sepenuhnya tidak perlu. Ini kira-kira sepuluh kali lebih cepat untuk menggunakan jenis perbandingan ordinal, yang membandingkan string dengan cara yang akrab untuk programmer C dan C++: dengan hanya membandingkan setiap ketepatan parut string, tanpa memperhatikan karakter yang diwakili oleh byte.</p> 
       <p>Beralih ke perbandingan string ordinal sesederhana memasok <code>StringComparison.Ordinal</code> sebagai argumen akhir untuk <code>String.Equals</code>:</p> 
       <pre><code>myString.Equals(otherString, StringComparison.Ordinal);

</code></pre> 
       <h2>API string built-in yang efisien</h2> 
       <p>Di luar beralih ke perbandingan ordinal, C # <code>String</code> API tertentu dikenal sangat tidak efisien. Di antara ini adalah <code>String.Format</code>, <code>String.StartsWith</code> dan <code>String.EndsWith</code>. <code>String.Format</code> sulit diganti, tetapi metode perbandingan string tidak efisien dioptimalkan.</p> 
       <p>Sementara rekomendasi Microsoft adalah untuk lulus <code>StringComparison.Ordinal</code> ke perbandingan string apa pun yang tidak perlu disesuaikan untuk lokalisasi, benchmark Unity menunjukkan bahwa dampak ini relatif minimal dibandingkan dengan implementasi kustom.</p> 
       <table> 
        <colgroup> 
         <col style="text-align:left;"> 
         <col style="text-align:left;"> 
        </colgroup> 
        <thead> 
         <tr> 
          <th style="text-align:left;">Method</th> 
          <th style="text-align:left;">Waktu (ms) untuk string pendek 100k</th> 
         </tr> 
        </thead> 
        <tbody> 
         <tr> 
          <td style="text-align:left;"> <code>String.StartsWith</code>, kultur default</td> 
          <td style="text-align:left;">Chili</td> 
         </tr> 
         <tr> 
          <td style="text-align:left;"> <code>String.EndsWith</code>, kultur default</td> 
          <td style="text-align:left;">142 g</td> 
         </tr> 
         <tr> 
          <td style="text-align:left;"> <code>String.StartsWith</code>, ordinal</td> 
          <td style="text-align:left;">115 g</td> 
         </tr> 
         <tr> 
          <td style="text-align:left;"> <code>String.EndsWith</code>, ordinal</td> 
          <td style="text-align:left;">Chili</td> 
         </tr> 
         <tr> 
          <td style="text-align:left;">penggantian <code>StartsWith</code> kustom</td> 
          <td style="text-align:left;">4.5</td> 
         </tr> 
         <tr> 
          <td style="text-align:left;">penggantian <code>EndsWith</code> kustom</td> 
          <td style="text-align:left;">4.5</td> 
         </tr> 
        </tbody> 
       </table> 
       <p>Kedua <code>String.StartsWith</code> dan <code>String.EndsWith</code> dapat diganti dengan versi yang dikodekan tangan sederhana, mirip dengan contoh yang terpasang di bawah ini.</p> 
       <pre><code>
    public static bool CustomEndsWith(this string a, string b)
    {
        int ap = a.Length - 1;
        int bp = b.Length - 1;
    
        while (ap &gt;= 0 &amp;&amp; bp &gt;= 0 &amp;&amp; a [ap] == b [bp])
        {
            ap--;
            bp--;
        }
    
        return (bp &lt; 0);
    }

    public static bool CustomStartsWith(this string a, string b)
    {
        int aLen = a.Length;
        int bLen = b.Length;
    
        int ap = 0; int bp = 0;
    
        while (ap &lt; aLen &amp;&amp; bp &lt; bLen &amp;&amp; a [ap] == b [bp])
        {
            ap++;
            bp++;
        }
    
        return (bp == bLen);
    }

</code></pre> 
       <h2>Ekspresi rutin</h2> 
       <p>Sitemap Expressions adalah cara yang kuat untuk mencocokkan dan memanipulasi string, mereka dapat sangat intensif. Lebih lanjut, karena implementasi C# dari Regular Expressions, bahkan pertanyaan Boolean <code>IsMatch</code> sederhana mengalokasikan struktur data transien besar "di bawah kap." Ini transien berhasil memori churn harus dianggap tidak dapat diterima, kecuali selama awalisasi.</p> 
       <p>Jika ekspresi rutin diperlukan, sangat dianjurkan untuk tidak menggunakan metode <code>Regex.Match</code> statis atau <code>Regex.Replace</code>, yang menerima ekspresi rutin sebagai parameter string. Metode ini mengkompilasi ekspresi rutin on-the-fly dan tidak cache objek yang dihasilkan.</p> 
       <p>Kode contoh ini adalah satu-liner yang tidak biasa.</p> 
       <pre><code>
Regex.Match(myString, "foo");

</code></pre> 
       <p>Namun, setiap kali dieksekusi, menghasilkan 5 kilobyte sampah. Refactoring sederhana dapat menghilangkan banyak sampah ini:</p> 
       <pre><code>
var myRegExp = new Regex("foo");

myRegExp.Match(myString);

</code></pre> 
       <p>Dalam contoh ini, setiap panggilan ke <code>myRegExp.Match</code> "hanya" menghasilkan 320 byte sampah. Meskipun ini masih mahal untuk operasi pencocokan sederhana, itu adalah peningkatan yang cukup besar atas contoh sebelumnya.</p> 
       <p>Oleh karena itu, jika ekspresi rutin adalah literal string invariant, itu jauh lebih efisien untuk menginjak mereka dengan melewatinya sebagai parameter pertama dari konstror objek Regex. Regexe prekompiled ini harus digunakan kembali.</p> 
       <h2>XML, JSON dan parsing teks bentuk panjang lainnya</h2> 
       <p>Membuat teks sering merupakan salah satu operasi yang paling berat yang terjadi pada waktu pemuatan. Kadang-kadang, waktu yang dihabiskan teks parsing dapat melampaui waktu yang dihabiskan memuat dan mengulang Aset.</p> 
       <p>Alasan di balik ini tergantung pada parser tertentu yang digunakan. C# built-in XML parser sangat fleksibel, tetapi sebagai hasilnya, tidak dapat dioptimalkan untuk tata letak data tertentu.</p> 
       <p>Banyak parsers pihak ketiga dibangun pada refleksi. Sementara refleksi adalah pilihan yang sangat baik selama pembangunan (karena itu memungkinkan parser untuk dengan cepat beradaptasi untuk mengubah tata letak data), sangat lambat.</p> 
       <p>Unity telah memperkenalkan solusi parsial dengan API <a href="../ScriptReference/JsonUtility.html">JSONUtility</a> built-in, yang menyediakan antarmuka ke sistem serialisasi Unity yang membaca / membatasi JSON. Di sebagian besar tolok, lebih cepat daripada C # JSON parsers murni, tetapi memiliki keterbatasan yang sama seperti antarmuka lain ke sistem serialisasi Unity - itu tidak dapat serialisasi banyak jenis data yang kompleks, seperti Dictionaries, tanpa kode tambahan.</p> 
       <p> <strong>Note</strong>: Lihat antarmuka <a href="../ScriptReference/ISerializationCallbackReceiver.html">ISerializationCallbackReceiver</a> untuk satu cara untuk menambahkan pemrosesan tambahan yang diperlukan untuk mengkonversi ke / dari jenis data yang kompleks selama proses serialisasi Unity.</p> 
       <p>Ketika menghadapi masalah kinerja yang timbul dari parsing data tekstual, mempertimbangkan tiga resolusi alternatif.</p> 
       <h3>Opsi 1: Parse pada waktu membangun</h3> 
       <p>Cara terbaik untuk menghindari biaya parsing teks adalah untuk sepenuhnya menghilangkan parsing teks pada runtime. Secara umum, ini berarti “baking” data tekstual ke dalam format biner melalui beberapa jenis langkah build.</p> 
       <p>Sebagian besar pengembang yang memilih untuk rute ini memindahkan data mereka ke semacam hierarki kelas ScriptableObject-derived dan kemudian mendistribusikan data melalui AssetBundles. Untuk diskusi yang sangat baik menggunakan ScriptableObjects, lihat <a href="https://www.youtube.com/watch?v=VBA1QCoEAX4">Richard Fine’s Unite 2016 berbicara</a> di youtube.</p> 
       <p>Strategi ini menawarkan kinerja terbaik, tetapi hanya cocok untuk data yang tidak perlu dihasilkan secara dinamis. paling cocok untuk parameter desain game dan konten lainnya.</p> 
       <h3>Opsi 2: Beban split dan malas</h3> 
       <p>Kemungkinan kedua adalah untuk membagi data yang harus dimasukkan ke dalam chunks yang lebih kecil. Setelah split, biaya parsing data dapat menyebar di beberapa bingkai. Dalam kasus yang ideal, mengidentifikasi bagian spesifik dari data yang diperlukan untuk menyajikan pengalaman yang diinginkan kepada pengguna dan memuat hanya bagian-bagian tersebut.</p> 
       <p>Dalam contoh sederhana: jika proyek adalah permainan platform, itu tidak akan perlu untuk serialisasi data untuk semua tingkat bersama menjadi satu raksasa blob. Jika data dibagi menjadi Aset individu untuk setiap tingkat, dan mungkin tersegmentasi tingkat ke daerah, data dapat diserang sebagai pemain mendekatinya.</p> 
       <p>Meskipun suara ini mudah, dalam prakteknya membutuhkan investasi substansial dalam kode alat dan mungkin memerlukan struktur data untuk diorganisasikan kembali.</p> 
       <h3>Opsi 3: Thread</h3> 
       <p>Untuk data yang parsed sepenuhnya menjadi objek C# biasa, dan tidak memerlukan interaksi dengan API Unity, dimungkinkan untuk memindahkan operasi parsing ke benang pekerja.</p> 
       <p>Opsi ini dapat sangat kuat pada platform dengan sejumlah besar inti. Namun, itu membutuhkan pemrograman yang cermat untuk menghindari membuat tengkar dan kondisi balap.</p> 
       <p> <strong>Note</strong>: Perangkat iOS memiliki sebagian besar 2 core. Kebanyakan perangkat Android memiliki dari 2 hingga 4. Teknik ini lebih menarik ketika membangun target membangun yang mandiri dan konsol.</p> 
       <p>Proyek yang memilih untuk menerapkan threading menggunakan built-in C # <a href="https://msdn.microsoft.com/en-us/library/system.threading.thread(v=vs.110).aspx">Thread</a> dan kelas <a href="https://msdn.microsoft.com/en-us/library/system.threading.threadpool(v=vs.110).aspx">ThreadPool</a> (lihat <a href="https://msdn.microsoft.com/en-us/library/system.threading.thread(v=vs.110).aspx">msdn.microsoft.com</a>) untuk mengelola benang pekerja mereka, bersama dengan kelas sinkronisasi C # standar.</p> 
       <!-- area:core --> 
       <div id="_content"></div> 
       <div class="nextprev clear"> 
        <div class="icon tt left mr1" data-distance="-40|-30|top"> 
         <span class="prev"><a href="BestPracticeUnderstandingPerformanceInUnity4.html"></a></span> 
         <div class="tip">
           Audit aset 
         </div> 
        </div> 
        <div class="icon tt right" data-distance="-40|-30|top"> 
         <span class="next"><a href="BestPracticeUnderstandingPerformanceInUnity6.html"></a></span> 
         <div class="tip">
           Folder Sumber Daya 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="footer-wrapper"> 
       <div class="footer clear"> 
        <div class="copy">
          © 2022 Unity Technologies. Tanggal Publikasi: 2022-04-04. 
        </div> 
        <div class="menu"> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div>  
 </body>
</html>
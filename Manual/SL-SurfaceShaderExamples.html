<!doctype html>
<html lang="en" class="no-js">
 <head> 
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> 
  <script type="text/javascript" src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" charset="UTF-8" data-domain-script="6e91be4c-3145-4ea2-aa64-89d716064836"></script> 
  <script type="text/javascript">
					function OptanonWrapper() { }
				</script> 
  <script>var offline=false;if(!offline){(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);  })(window,document,'script','dataLayer','GTM-K8K24X8');}</script> 
  <link href="https://fonts.googleapis.com/css?family=Roboto&amp;display=swap" rel="stylesheet"> 
  <meta charset="utf-8"> 
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <title>Unity - Manual: Contoh Shader Permukaan</title> 
  <meta property="og:image" content="https://unity3d.com/files/images/ogimg.jpg"> 
  <meta name="author" content="Unity Technologies"> 
  <link rel="shortcut icon" href="https://unity.com/themes/contrib/unity_base/images/favicons/favicon.ico"> 
  <link rel="icon" type="image/png" href="../StaticFilesManual/images/favicons/favicon.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../StaticFilesManual/images/favicons/apple-touch-icon-152x152.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../StaticFilesManual/images/favicons/apple-touch-icon-144x144.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="../StaticFilesManual/images/favicons/apple-touch-icon-120x120.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../StaticFilesManual/images/favicons/apple-touch-icon-114x114.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../StaticFilesManual/images/favicons/apple-touch-icon-72x72.png"> 
  <link rel="apple-touch-icon-precomposed" href="../StaticFilesManual/images/favicons/apple-touch-icon.png"> 
  <meta name="msapplication-TileColor" content="#222c37"> 
  <meta name="msapplication-TileImage" content="../StaticFilesManual/images/favicons/tileicon-144x144.png"> 
  <script type="text/javascript" src="https://docs.unity3d.com/StaticFilesConfig/UnityVersionsInfo.js"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/jquery.js?ts=20220404"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/core.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/toc.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/global_toc.js?ts=20220404"></script> 
  <link rel="stylesheet" type="text/css" href="../StaticFilesManual/css/core.css?ts=20220404"> 
  <link rel="stylesheet" href="../StaticFilesManual/css/prism.css"> 
  <script src="../StaticFilesManual/js/prism.js"></script> 
  <script src="/StaticFilesConfig/feedback/feedback.js"></script> 
  <script src="../StaticFilesManual/js/jquery.sidebar.min.js"></script> 
  <link rel="stylesheet" href="../StaticFilesManual/css/mobileoptimisation.css"> 
  <script src="../StaticFilesManual/js/mobileoptimisation.js"></script> 
 </head> 
 <body> 
  <noscript> 
   <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K8K24X8" height="0" width="0" style="display:none;visibility:hidden"></iframe> 
  </noscript> 
  <div id="DocsAnalyticsData" data-area="none" data-pagetype="manual"></div> 
  <div class="header-wrapper"> 
   <div id="header" class="header"> 
    <div class="content"> 
     <div class="spacer"> 
      <div class="menu"> 
       <div id="nav-open" for="nav-input"> 
        <span></span> 
       </div> 
       <div class="logo"></div> 
       <div class="search-form"> 
        <form action="30_search.html" method="get" class="apisearch"> 
         <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
         <input type="submit" class="submit"> 
        </form> 
       </div> 
       <ul> 
        <li><a href="../Manual/index.html" class="selected">Manual</a></li> 
        <li><a href="../ScriptReference/index.html">API documentation</a></li> 
       </ul> 
      </div> 
     </div> 
     <div class="more"> 
      <div class="filler"></div> 
      <ul> 
       <li></li> 
      </ul> 
     </div> 
    </div> 
   </div> 
   <div class="toolbar"> 
    <div class="content"> 
    </div> 
   </div> 
   <div class="mobileLogo"></div> 
  </div> 
  <div id="master-wrapper" class="master-wrapper clear"> 
   <div id="sidebar" class="sidebar"> 
    <div class="sidebar-wrap"> 
     <div class="content"> 
      <div class="sidebar-menu"> 
       <div class="toc" id="customScrollbar"> 
        <h2>Manual Unity</h2> 
        <div class="search-form sidebar-search-form"> 
         <form action="30_search.html" method="get" class="apisearch"> 
          <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
          <input type="submit" id="mobileSearchBtn" class="submit" value="Search"> 
         </form> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div id="content-wrap" class="content-wrap"> 
    <div class="content-block"> 
     <div class="content"> 
      <div class="section"> 
       <div class="breadcrumbs clear"> 
        <ul> 
         <li><a href="UnityManual.html">Manual Pengguna Unity 2022.1 (beta)</a></li> 
         <li><a href="Graphics.html">Graphics</a></li> 
         <li><a href="Shaders.html">Shaders</a></li> 
         <li><a href="shader-writing.html">Menu Menu</a></li> 
         <li><a href="SL-SurfaceShaders.html">Menulis Permukaan Shaders</a></li> 
         <li>Contoh Shader permukaan</li> 
        </ul> 
       </div> 
       <div class="mb20"> 
        <div class="nextprev clear"> 
         <div class="icon tt left mr1" data-distance="-40|-30|top"> 
          <span class="prev"><a href="SL-RenderPipeline.html"></a></span> 
          <div class="tip">
            Permukaan Shader dan jalur rendering 
          </div> 
         </div> 
         <div class="icon tt right" data-distance="-40|-30|top"> 
          <span class="next"><a href="SL-SurfaceShaderLighting.html"></a></span> 
          <div class="tip">
            Model pencahayaan khusus di Permukaan Shaders 
          </div> 
         </div> 
        </div> 
       </div> 
       <div id="_leavefeedback"></div> 
       <h1>Contoh Shader permukaan</h1> 
       <!--BeginSwitchLink--> 
       <!--EndSwitchLink--> 
       <div class="clear"></div> 
       <p>Contoh <span class="tooltip"><a class="tooltipMoreInfoLink" href="SL-SurfaceShaders.html">Permukaan Shader</a><span class="tooltiptext">Cara merampingkan naungan menulis untuk Pipeline Render Built-in. <a href="SL-SurfaceShaders.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#SurfaceShader">Glossary</a></span></span></span> pada halaman ini menunjukkan cara menggunakan model pencahayaan built-in. Sebagai contoh tentang cara menerapkan model pencahayaan kustom, lihat <a href="SL-SurfaceShaderLightingExamples.html">Contoh Pencahayaan Shader Permukaan</a>.</p> 
       <p>Di Pipelne Render Built-in, Surface <span class="tooltip"><strong>Shaders</strong><span class="tooltiptext">Program yang berjalan di GPU. <a class="tooltipMoreInfoLink" href="Shaders.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Shader">Glossary</a></span></span></span> adalah cara merampingkan naungan menulis yang berinteraksi dengan pencahayaan.</p> 
       <h2>Kompatibilitas pipa Render</h2> 
       <table> 
        <colgroup> 
         <col style="text-align:left;"> 
         <col style="text-align:left;"> 
         <col style="text-align:left;"> 
         <col style="text-align:left;"> 
         <col style="text-align:left;"> 
        </colgroup> 
        <thead> 
         <tr> 
          <th style="text-align:left;"><strong>Feature name</strong></th> 
          <th style="text-align:left;"><strong>Built-in <span class="tooltip"><strong>Render Pipeline</strong><span class="tooltiptext">A series of operations that take the contents of a Scene, and displays them on a screen. Unity lets you choose from pre-built render pipelines, or write your own. <a class="tooltipMoreInfoLink" href="render-pipelines.html">More info</a><br><span class="tooltipGlossaryLink">See in <a href="Glossary.html#Renderpipeline">Glossary</a></span></span></span></strong></th> 
          <th style="text-align:left;"><strong>Universal Render Pipeline (URP)</strong></th> 
          <th style="text-align:left;"><strong>High Definition Render Pipeline (HDRP)</strong></th> 
          <th style="text-align:left;"><strong>Custom SRP</strong></th> 
         </tr> 
        </thead> 
        <tbody> 
         <tr> 
          <td style="text-align:left;"><strong>Surface Shaders</strong></td> 
          <td style="text-align:left;">Yes</td> 
          <td style="text-align:left;">No<br><br> Untuk cara merampingkan menciptakan benda-benda Shader di URP, lihat <a href="shader-graph.html">Shader Graph</a>.</td> 
          <td style="text-align:left;">No<br><br> Untuk cara ramping menciptakan benda-benda Shader di HDRP, lihat <a href="shader-graph.html">Shader Graph</a>.</td> 
          <td style="text-align:left;">No</td> 
         </tr> 
        </tbody> 
       </table> 
       <h2>sederhana naungan contoh</h2> 
       <p>Kita akan mulai dengan Shader yang sangat sederhana dan membangunnya. Ini adalah Shader yang mengatur warna permukaan untuk "putih". Ini menggunakan model pencahayaan Lambert built-in.</p> 
       <pre><code>  Shader "Example/Diffuse Simple" {
    SubShader {
      Tags { "RenderType" = "Opaque" }
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
          float4 color : COLOR;
      };
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = 1;
      }
      ENDCG
    }
    Fallback "Diffuse"
  }
</code></pre> 
       <p>Berikut ini bagaimana terlihat seperti pada model dengan dua setelan <a href="class-Light.html">Lights</a>:</p> 
       <figure> 
        <img src="https://docs.unity3d.com/2022.1/Documentation/uploads/Main/SurfaceShaderSimple.jpg" alt=""> 
       </figure> 
       <h2>Texture</h2> 
       <p>Objek all-white cukup membosankan, jadi mari tambahkan Tekstur. Kami akan menambahkan blok <a href="SL-Properties.html">Properties</a> ke Shader, jadi kami mendapatkan pemilih Tekstur dalam Bahan kami.</p> 
       <pre><code>  Shader "Example/Diffuse Texture" {
    Properties {
      _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader {
      Tags { "RenderType" = "Opaque" }
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
          float2 uv_MainTex;
      };
      sampler2D _MainTex;
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
      }
      ENDCG
    } 
    Fallback "Diffuse"
  }
</code></pre> 
       <figure> 
        <img src="https://docs.unity3d.com/2022.1/Documentation/uploads/Main/SurfaceShaderDiffuseTex.jpg" alt=""> 
       </figure> 
       <h2>Pemetaan normal</h2> 
       <p>Mari kita tambahkan beberapa pemetaan normal:</p> 
       <pre><code>  Shader "Example/Diffuse Bump" {
    Properties {
      _MainTex ("Texture", 2D) = "white" {}
      _BumpMap ("Bumpmap", 2D) = "bump" {}
    }
    SubShader {
      Tags { "RenderType" = "Opaque" }
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
        float2 uv_MainTex;
        float2 uv_BumpMap;
      };
      sampler2D _MainTex;
      sampler2D _BumpMap;
      void surf (Input IN, inout SurfaceOutput o) {
        o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
        o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));
      }
      ENDCG
    } 
    Fallback "Diffuse"
  }
</code></pre> 
       <figure> 
        <img src="https://docs.unity3d.com/2022.1/Documentation/uploads/Main/SurfaceShaderDiffuseBump.jpg" alt=""> 
       </figure> 
       <h2>Pencahayaan Rim</h2> 
       <p>Sekarang, coba tambahkan beberapa Rim Lighting untuk menyoroti tepi <span class="tooltip"><strong>GameObject</strong><span class="tooltiptext">Objek mendasar dalam adegan Unity, yang dapat mewakili karakter, props, pemandangan, kamera, waypoints, dan banyak lagi. Fungsi GameObject didefinisikan oleh Komponen yang melekat padanya. <a class="tooltipMoreInfoLink" href="class-GameObject.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#GameObject">Glossary</a></span></span></span>. Kami akan menambahkan beberapa cahaya yang diizinkan berdasarkan sudut antara permukaan normal dan sudut pandang. Untuk itu, kami akan menggunakan variabel permukaan Shader built-in.<code>viewDir</code> Surface Shader variable.</p> 
       <pre><code>  Shader "Example/Rim" {
    Properties {
      _MainTex ("Texture", 2D) = "white" {}
      _BumpMap ("Bumpmap", 2D) = "bump" {}
      _RimColor ("Rim Color", Color) = (0.26,0.19,0.16,0.0)
      _RimPower ("Rim Power", Range(0.5,8.0)) = 3.0
    }
    SubShader {
      Tags { "RenderType" = "Opaque" }
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
          float2 uv_MainTex;
          float2 uv_BumpMap;
          float3 viewDir;
      };
      sampler2D _MainTex;
      sampler2D _BumpMap;
      float4 _RimColor;
      float _RimPower;
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
          o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));
          half rim = 1.0 - saturate(dot (normalize(IN.viewDir), o.Normal));
          o.Emission = _RimColor.rgb * pow (rim, _RimPower);
      }
      ENDCG
    } 
    Fallback "Diffuse"
  }
</code></pre> 
       <figure> 
        <img src="https://docs.unity3d.com/2022.1/Documentation/uploads/Main/SurfaceShaderRim.jpg" alt=""> 
       </figure> 
       <h2>Detail Tekstur</h2> 
       <p>Untuk efek yang berbeda, mari tambahkan Tekstur Detail yang dikombinasikan dengan Tekstur dasar. Tekstur Detail biasanya menggunakan UV yang sama tetapi Tiling yang berbeda dalam Bahan, sehingga kita perlu menggunakan masukan yang berbeda koordinasi UV.</p> 
       <pre><code>  Shader "Example/Detail" {
    Properties {
      _MainTex ("Texture", 2D) = "white" {}
      _BumpMap ("Bumpmap", 2D) = "bump" {}
      _Detail ("Detail", 2D) = "gray" {}
    }
    SubShader {
      Tags { "RenderType" = "Opaque" }
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
          float2 uv_MainTex;
          float2 uv_BumpMap;
          float2 uv_Detail;
      };
      sampler2D _MainTex;
      sampler2D _BumpMap;
      sampler2D _Detail;
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
          o.Albedo *= tex2D (_Detail, IN.uv_Detail).rgb * 2;
          o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));
      }
      ENDCG
    } 
    Fallback "Diffuse"
  }
</code></pre> 
       <p>Menggunakan checker Tekstur tidak selalu membuat rasa praktis, tetapi dalam contoh ini digunakan untuk menggambarkan apa yang terjadi:</p> 
       <figure> 
        <img src="https://docs.unity3d.com/2022.1/Documentation/uploads/Main/SurfaceShaderDetailTex.jpg" alt=""> 
       </figure> 
       <h2>Tekstur Detail di Ruang Layar</h2> 
       <p>Tekstur Detail di ruang layar tidak membuat rasa praktis untuk model kepala tentara, tetapi di sini digunakan untuk menggambarkan bagaimana input <code>screenPos</code> built-in mungkin digunakan:</p> 
       <pre><code>  Shader "Example/ScreenPos" {
    Properties {
      _MainTex ("Texture", 2D) = "white" {}
      _Detail ("Detail", 2D) = "gray" {}
    }
    SubShader {
      Tags { "RenderType" = "Opaque" }
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
          float2 uv_MainTex;
          float4 screenPos;
      };
      sampler2D _MainTex;
      sampler2D _Detail;
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
          float2 screenUV = IN.screenPos.xy / IN.screenPos.w;
          screenUV *= float2(8,6);
          o.Albedo *= tex2D (_Detail, screenUV).rgb * 2;
      }
      ENDCG
    } 
    Fallback "Diffuse"
  }
</code></pre> 
       <p>Pemetaan normal telah dihapus dari Shader di atas, hanya untuk membuatnya lebih pendek:</p> 
       <figure> 
        <img src="https://docs.unity3d.com/2022.1/Documentation/uploads/Main/SurfaceShaderDetailTexScreenPos.jpg" alt=""> 
       </figure> 
       <h2>Catalog</h2> 
       <p>Ini adalah seorang Shader yang melakukan refleksi cubemapped menggunakan input <code>worldRefl</code> bawaan. Hal ini sangat mirip dengan built-in Reflective/Diffuse Shader:</p> 
       <pre><code>  Shader "Example/WorldRefl" {
    Properties {
      _MainTex ("Texture", 2D) = "white" {}
      _Cube ("Cubemap", CUBE) = "" {}
    }
    SubShader {
      Tags { "RenderType" = "Opaque" }
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
          float2 uv_MainTex;
          float3 worldRefl;
      };
      sampler2D _MainTex;
      samplerCUBE _Cube;
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb * 0.5;
          o.Emission = texCUBE (_Cube, IN.worldRefl).rgb;
      }
      ENDCG
    } 
    Fallback "Diffuse"
  }
</code></pre> 
       <p>Karena itu menetapkan warna refleksi sebagai <strong>Emission</strong>, kita mendapatkan prajurit yang sangat mengkilap:</p> 
       <figure> 
        <img src="https://docs.unity3d.com/2022.1/Documentation/uploads/Main/SurfaceShaderWorldRefl.jpg" alt=""> 
       </figure> 
       <p>Jika Anda ingin melakukan refleksi yang dipengaruhi oleh <span class="tooltip"><strong>normal maps</strong><span class="tooltiptext">Jenis tekstur Peta Bump yang memungkinkan Anda untuk menambahkan detail permukaan seperti benjolan, alur, dan goresan ke model yang menangkap cahaya seolah-olah mereka diwakili oleh geometri nyata.<br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Normalmap">Glossary</a></span></span></span>, perlu sedikit lebih terlibat: <code>INTERNAL_DATA</code> perlu ditambahkan ke struktur <code>Input</code>, dan fungsi <code>WorldReflectionVector</code> digunakan untuk menghitung vektor refleksi per-pixel setelah Anda telah menulis output normal.</p> 
       <pre><code>  Shader "Example/WorldRefl Normalmap" {
    Properties {
      _MainTex ("Texture", 2D) = "white" {}
      _BumpMap ("Bumpmap", 2D) = "bump" {}
      _Cube ("Cubemap", CUBE) = "" {}
    }
    SubShader {
      Tags { "RenderType" = "Opaque" }
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
          float2 uv_MainTex;
          float2 uv_BumpMap;
          float3 worldRefl;
          INTERNAL_DATA
      };
      sampler2D _MainTex;
      sampler2D _BumpMap;
      samplerCUBE _Cube;
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb * 0.5;
          o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));
          o.Emission = texCUBE (_Cube, WorldReflectionVector (IN, o.Normal)).rgb;
      }
      ENDCG
    } 
    Fallback "Diffuse"
  }
</code></pre> 
       <p>Ini adalah tentara shiny maped normal:</p> 
       <figure> 
        <img src="https://docs.unity3d.com/2022.1/Documentation/uploads/Main/SurfaceShaderWorldReflNormalmap.jpg" alt=""> 
       </figure> 
       <h2>Slices melalui Posisi Ruang Dunia</h2> 
       <p>Berikut adalah Shader yang “slices” GameObject dengan membuang <span class="tooltip"><strong>pixels</strong><span class="tooltiptext">Unit terkecil dalam gambar komputer. Ukuran piksel tergantung pada resolusi layar Anda. Pencahayaan pixel dihitung pada setiap piksel layar. <a class="tooltipMoreInfoLink" href="ShadowPerformance.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#pixel">Glossary</a></span></span></span> dalam cincin hampir horisontal. Hal ini dilakukan dengan menggunakan fungsi <code>clip()</code> Cg / HLSL berdasarkan posisi dunia pixel. Kita akan menggunakan variabel permukaan Shader built-in.<code>worldPos</code> Surface Shader variable.</p> 
       <pre><code>  Shader "Example/Slices" {
    Properties {
      _MainTex ("Texture", 2D) = "white" {}
      _BumpMap ("Bumpmap", 2D) = "bump" {}
    }
    SubShader {
      Tags { "RenderType" = "Opaque" }
      Cull Off
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
          float2 uv_MainTex;
          float2 uv_BumpMap;
          float3 worldPos;
      };
      sampler2D _MainTex;
      sampler2D _BumpMap;
      void surf (Input IN, inout SurfaceOutput o) {
          clip (frac((IN.worldPos.y+IN.worldPos.z*0.1) * 5) - 0.5);
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
          o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));
      }
      ENDCG
    } 
    Fallback "Diffuse"
  }
</code></pre> 
       <figure> 
        <img src="https://docs.unity3d.com/2022.1/Documentation/uploads/Main/SurfaceShaderSlices.jpg" alt=""> 
       </figure> 
       <h2>Ekstrusi normal dengan pengubah Vertex</h2> 
       <p>Hal ini dimungkinkan untuk menggunakan fungsi “vertex modifier” yang akan mengubah data simpul masuk dalam <span class="tooltip"><strong>vertex Shader</strong><span class="tooltiptext">Program yang berjalan pada setiap simpul model 3D ketika model sedang diberikan. <a class="tooltipMoreInfoLink" href="SL-ShaderPrograms.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#vertexshader">Glossary</a></span></span></span>. Ini dapat digunakan untuk hal-hal seperti animasi prosedural dan ekstrusi sepanjang normal. Permukaan Shader kompilasi directive <code>vertex:functionName</code> digunakan untuk itu, dengan fungsi yang mengambil parameter <code>inout appdata_full</code>.</p> 
       <p>Berikut adalah Shader yang bergerak vertices sepanjang normal mereka dengan jumlah yang ditentukan dalam Bahan:</p> 
       <pre><code>  Shader "Example/Normal Extrusion" {
    Properties {
      _MainTex ("Texture", 2D) = "white" {}
      _Amount ("Extrusion Amount", Range(-1,1)) = 0.5
    }
    SubShader {
      Tags { "RenderType" = "Opaque" }
      CGPROGRAM
      #pragma surface surf Lambert vertex:vert
      struct Input {
          float2 uv_MainTex;
      };
      float _Amount;
      void vert (inout appdata_full v) {
          v.vertex.xyz += v.normal * _Amount;
      }
      sampler2D _MainTex;
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
      }
      ENDCG
    } 
    Fallback "Diffuse"
  }
</code></pre> 
       <p>Bergerak vertices sepanjang normal mereka membuat tentara lemak:</p> 
       <figure> 
        <img src="https://docs.unity3d.com/2022.1/Documentation/uploads/Main/SurfaceShaderNormalExtrusion.jpg" alt=""> 
       </figure> 
       <h2>Data kustom computed per-vertex</h2> 
       <p>Menggunakan fungsi pengubah simpul, juga dimungkinkan untuk mengimbangi data kustom di Shader simpul, yang kemudian akan dilewatkan ke fungsi Shader Permukaan per-piksel. kompilasi yang sama directive <code>vertex:functionName</code> digunakan, tetapi fungsi harus mengambil dua parameter: <code>inout appdata_full</code> dan <code>out Input</code>. Anda dapat mengisi setiap anggota Input yang bukan nilai bawaan di sana.</p> 
       <p>Sitemap Sitemap Anggota input yang digunakan dalam cara ini tidak harus memiliki nama dimulai dengan 'uv' atau mereka tidak akan bekerja dengan benar.<strong>Note:</strong> Custom Input members used in this way must not have names beginning with ‘uv’ or they won’t work properly.</p> 
       <p>Contoh di bawah ini mendefinisikan anggota <code>float3 customColor</code> kustom, yang dihitung dalam fungsi simpul:</p> 
       <pre><code>  Shader "Example/Custom Vertex Data" {
    Properties {
      _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader {
      Tags { "RenderType" = "Opaque" }
      CGPROGRAM
      #pragma surface surf Lambert vertex:vert
      struct Input {
          float2 uv_MainTex;
          float3 customColor;
      };
      void vert (inout appdata_full v, out Input o) {
          UNITY_INITIALIZE_OUTPUT(Input,o);
          o.customColor = abs(v.normal);
      }
      sampler2D _MainTex;
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
          o.Albedo *= IN.customColor;
      }
      ENDCG
    } 
    Fallback "Diffuse"
  }
</code></pre> 
       <p>Dalam contoh ini <code>customColor</code> diatur ke nilai absolut normal:</p> 
       <figure> 
        <img src="https://docs.unity3d.com/2022.1/Documentation/uploads/Main/SurfaceShaderCustomVertexData.jpg" alt=""> 
       </figure> 
       <p>Penggunaan yang lebih praktis bisa mengkomputasikan data per-vertex yang tidak disediakan oleh variabel input bawaan; atau mengoptimalkan komputasi Shader. Misalnya, dimungkinkan untuk mengimbangi pencahayaan Rim di simpul GameObject, alih-alih melakukan itu di permukaan Shader per-pixel.</p> 
       <h2>Pengubah Warna Akhir</h2> 
       <p>Hal ini dimungkinkan untuk menggunakan fungsi pengubah warna akhir yang akan mengubah warna akhir yang dihitung oleh Shader. Permukaan Shader kompilasi directive <code>finalcolor:functionName</code> digunakan untuk ini, dengan fungsi yang mengambil parameter <code>Input IN, SurfaceOutput o, inout fixed4 color</code>.</p> 
       <p>Ini adalah Shader sederhana yang menerapkan warna akhir. Ini berbeda dari hanya menerapkan warna tint ke permukaan Albedo: kaleng ini juga akan mempengaruhi warna yang berasal dari <span class="tooltip"><strong>Lightmaps</strong><span class="tooltiptext">Tekstur pra-render yang mengandung efek sumber cahaya pada objek statis di tempat kejadian. Lightmaps dilalui atas geometri adegan untuk menciptakan efek pencahayaan. <a class="tooltipMoreInfoLink" href="Lightmapping.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a class="tooltipMoreInfoLink" href="Glossary.html#Lightmap">Glossary</a></span></span></span>, <span class="tooltip"><strong>Light Probes</strong><span class="tooltiptext">probe cahaya menyimpan informasi tentang bagaimana cahaya melewati ruang di tempat kejadian Anda. Koleksi probe cahaya yang diatur dalam ruang tertentu dapat meningkatkan pencahayaan pada objek bergerak dan pemandangan LOD statis dalam ruang itu. <a href="LightProbes.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#LightProbe">Glossary</a></span></span></span> dan sumber ekstra serupa.</p> 
       <pre><code>  Shader "Example/Tint Final Color" {
    Properties {
      _MainTex ("Texture", 2D) = "white" {}
      _ColorTint ("Tint", Color) = (1.0, 0.6, 0.6, 1.0)
    }
    SubShader {
      Tags { "RenderType" = "Opaque" }
      CGPROGRAM
      #pragma surface surf Lambert finalcolor:mycolor
      struct Input {
          float2 uv_MainTex;
      };
      fixed4 _ColorTint;
      void mycolor (Input IN, SurfaceOutput o, inout fixed4 color)
      {
          color *= _ColorTint;
      }
      sampler2D _MainTex;
      void surf (Input IN, inout SurfaceOutput o) {
           o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
      }
      ENDCG
    } 
    Fallback "Diffuse"
  }
</code></pre> 
       <figure> 
        <img src="https://docs.unity3d.com/2022.1/Documentation/uploads/Main/SurfaceShaderFinalColorSimple.jpg" alt=""> 
       </figure> 
       <h2>Fog kustom dengan pengubah warna akhir</h2> 
       <p>Kasus umum untuk menggunakan pengubah warna akhir (lihat di atas) akan menerapkan Fog sepenuhnya kustom di <span class="tooltip"><strong>forward rendering</strong><span class="tooltiptext">Sebuah jalur rendering yang membuat setiap objek dalam satu atau lebih melewati, tergantung pada lampu yang mempengaruhi objek. Lampu sendiri juga diperlakukan berbeda dengan Rendering Maju, tergantung pada pengaturan dan intensitas mereka. <a class="tooltipMoreInfoLink" href="RenderTech-ForwardRendering.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#ForwardRendering">Glossary</a></span></span></span>. Fog perlu mempengaruhi akhir computed pixel Shader warna, yang persis apa modifier <code>finalcolor</code>.</p> 
       <p>Ini adalah Shader yang menerapkan kaleng kabut berdasarkan jarak dari pusat layar. Ini menggabungkan modifier vertex dengan data vertex kustom (<code>fog</code>) dan pengubah warna akhir. Ketika digunakan dalam lanjutan rendering aditif lulus, Fog perlu memudar ke hitam. Contoh ini menangani dan melakukan cek untuk <code>UNITY_PASS_FORWARDADD</code>.</p> 
       <pre><code>  Shader "Example/Fog via Final Color" {
    Properties {
      _MainTex ("Texture", 2D) = "white" {}
      _FogColor ("Fog Color", Color) = (0.3, 0.4, 0.7, 1.0)
    }
    SubShader {
      Tags { "RenderType" = "Opaque" }
      CGPROGRAM
      #pragma surface surf Lambert finalcolor:mycolor vertex:myvert
      struct Input {
          float2 uv_MainTex;
          half fog;
      };
      void myvert (inout appdata_full v, out Input data)
      {
          UNITY_INITIALIZE_OUTPUT(Input,data);
          float4 hpos = UnityObjectToClipPos(v.vertex);
          hpos.xy/=hpos.w;
          data.fog = min (1, dot (hpos.xy, hpos.xy)*0.5);
      }
      fixed4 _FogColor;
      void mycolor (Input IN, SurfaceOutput o, inout fixed4 color)
      {
          fixed3 fogColor = _FogColor.rgb;
          #ifdef UNITY_PASS_FORWARDADD
          fogColor = 0;
          #endif
          color.rgb = lerp (color.rgb, fogColor, IN.fog);
      }
      sampler2D _MainTex;
      void surf (Input IN, inout SurfaceOutput o) {
           o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
      }
      ENDCG
    } 
    Fallback "Diffuse"
  }
</code></pre> 
       <figure> 
        <img src="https://docs.unity3d.com/2022.1/Documentation/uploads/Main/SurfaceShaderFinalColorFog.jpg" alt=""> 
       </figure> 
       <h2>Fog</h2> 
       <pre><code>Shader "Example/Linear Fog" {
  Properties {
    _MainTex ("Base (RGB)", 2D) = "white" {}
  }
  SubShader {
    Tags { "RenderType"="Opaque" }
    LOD 200
    
    CGPROGRAM
    #pragma surface surf Lambert finalcolor:mycolor vertex:myvert
    #pragma multi_compile_fog

    sampler2D _MainTex;
    uniform half4 unity_FogStart;
    uniform half4 unity_FogEnd;

    struct Input {
      float2 uv_MainTex;
      half fog;
    };

    void myvert (inout appdata_full v, out Input data) {
      UNITY_INITIALIZE_OUTPUT(Input,data);
      float pos = length(UnityObjectToViewPos(v.vertex).xyz);
      float diff = unity_FogEnd.x - unity_FogStart.x;
      float invDiff = 1.0f / diff;
      data.fog = clamp ((unity_FogEnd.x - pos) * invDiff, 0.0, 1.0);
    }
    void mycolor (Input IN, SurfaceOutput o, inout fixed4 color) {
      #ifdef UNITY_PASS_FORWARDADD
        UNITY_APPLY_FOG_COLOR(IN.fog, color, float4(0,0,0,0));
      #else
        UNITY_APPLY_FOG_COLOR(IN.fog, color, unity_FogColor);
      #endif
    }

    void surf (Input IN, inout SurfaceOutput o) {
      half4 c = tex2D (_MainTex, IN.uv_MainTex);
      o.Albedo = c.rgb;
      o.Alpha = c.a;
    }
    ENDCG
  } 
  FallBack "Diffuse"
}
</code></pre> 
       <h2>Decals</h2> 
       <p>Decals umumnya digunakan untuk menambahkan rincian ke Bahan pada waktu lari (misalnya, dampak peluru). Mereka sangat berguna dalam rendering yang rusak, karena mereka mengubah GBuffer sebelum menyala, karena itu menghemat kinerja.</p> 
       <p>Dalam skenario yang khas, Decals harus diberikan setelah benda buram dan tidak boleh kasir bayangan, seperti yang terlihat pada "Tags" di contoh di bawah ini.<span class="tooltip"><strong>ShaderLab</strong><span class="tooltiptext">Bahasa Unity untuk mendefinisikan struktur benda-benda Shader. <a class="tooltipMoreInfoLink" href="SL-Shader.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#ShaderLab">Glossary</a></span></span></span> “Tags” in the example below.</p> 
       <pre><code>Shader "Example/Decal" {
  Properties {
    _MainTex ("Base (RGB)", 2D) = "white" {}
  }
  SubShader {
    Tags { "RenderType"="Opaque" "Queue"="Geometry+1" "ForceNoShadowCasting"="True" }
    LOD 200
    Offset -1, -1
    
    CGPROGRAM
    #pragma surface surf Lambert decal:blend
    
    sampler2D _MainTex;
    
    struct Input {
      float2 uv_MainTex;
    };
    
    void surf (Input IN, inout SurfaceOutput o) {
        half4 c = tex2D (_MainTex, IN.uv_MainTex);
        o.Albedo = c.rgb;
        o.Alpha = c.a;
      }
    ENDCG
    }
}
</code></pre> 
       <div id="_content"></div> 
       <div class="nextprev clear"> 
        <div class="icon tt left mr1" data-distance="-40|-30|top"> 
         <span class="prev"><a href="SL-RenderPipeline.html"></a></span> 
         <div class="tip">
           Permukaan Shader dan jalur rendering 
         </div> 
        </div> 
        <div class="icon tt right" data-distance="-40|-30|top"> 
         <span class="next"><a href="SL-SurfaceShaderLighting.html"></a></span> 
         <div class="tip">
           Model pencahayaan khusus di Permukaan Shaders 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="footer-wrapper"> 
       <div class="footer clear"> 
        <div class="copy">
          © 2022 Unity Technologies. Tanggal Publikasi: 2022-04-04. 
        </div> 
        <div class="menu"> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div>  
 </body>
</html>
<!doctype html>
<html lang="en" class="no-js">
 <head> 
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> 
  <script type="text/javascript" src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" charset="UTF-8" data-domain-script="6e91be4c-3145-4ea2-aa64-89d716064836"></script> 
  <script type="text/javascript">
					function OptanonWrapper() { }
				</script> 
  <script>var offline=false;if(!offline){(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);  })(window,document,'script','dataLayer','GTM-K8K24X8');}</script> 
  <link href="https://fonts.googleapis.com/css?family=Roboto&amp;display=swap" rel="stylesheet"> 
  <meta charset="utf-8"> 
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <title>Unity - Manual: Optimasi khusus</title> 
  <meta property="og:image" content="https://unity3d.com/files/images/ogimg.jpg"> 
  <meta name="author" content="Unity Technologies"> 
  <link rel="shortcut icon" href="https://unity.com/themes/contrib/unity_base/images/favicons/favicon.ico"> 
  <link rel="icon" type="image/png" href="../StaticFilesManual/images/favicons/favicon.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../StaticFilesManual/images/favicons/apple-touch-icon-152x152.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../StaticFilesManual/images/favicons/apple-touch-icon-144x144.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="../StaticFilesManual/images/favicons/apple-touch-icon-120x120.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../StaticFilesManual/images/favicons/apple-touch-icon-114x114.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../StaticFilesManual/images/favicons/apple-touch-icon-72x72.png"> 
  <link rel="apple-touch-icon-precomposed" href="../StaticFilesManual/images/favicons/apple-touch-icon.png"> 
  <meta name="msapplication-TileColor" content="#222c37"> 
  <meta name="msapplication-TileImage" content="../StaticFilesManual/images/favicons/tileicon-144x144.png"> 
  <script type="text/javascript" src="https://docs.unity3d.com/StaticFilesConfig/UnityVersionsInfo.js"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/jquery.js?ts=20220404"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/core.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/toc.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/global_toc.js?ts=20220404"></script> 
  <link rel="stylesheet" type="text/css" href="../StaticFilesManual/css/core.css?ts=20220404"> 
  <link rel="stylesheet" href="../StaticFilesManual/css/prism.css"> 
  <script src="../StaticFilesManual/js/prism.js"></script> 
  <script src="/StaticFilesConfig/feedback/feedback.js"></script> 
  <script src="../StaticFilesManual/js/jquery.sidebar.min.js"></script> 
  <link rel="stylesheet" href="../StaticFilesManual/css/mobileoptimisation.css"> 
  <script src="../StaticFilesManual/js/mobileoptimisation.js"></script> 
 </head> 
 <body> 
  <noscript> 
   <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K8K24X8" height="0" width="0" style="display:none;visibility:hidden"></iframe> 
  </noscript> 
  <div id="DocsAnalyticsData" data-area="core" data-pagetype="manual"></div> 
  <div class="header-wrapper"> 
   <div id="header" class="header"> 
    <div class="content"> 
     <div class="spacer"> 
      <div class="menu"> 
       <div id="nav-open" for="nav-input"> 
        <span></span> 
       </div> 
       <div class="logo"></div> 
       <div class="search-form"> 
        <form action="30_search.html" method="get" class="apisearch"> 
         <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
         <input type="submit" class="submit"> 
        </form> 
       </div> 
       <ul> 
        <li><a href="../Manual/index.html" class="selected">Manual</a></li> 
        <li><a href="../ScriptReference/index.html">API documentation</a></li> 
       </ul> 
      </div> 
     </div> 
     <div class="more"> 
      <div class="filler"></div> 
      <ul> 
       <li></li> 
      </ul> 
     </div> 
    </div> 
   </div> 
   <div class="toolbar"> 
    <div class="content"> 
    </div> 
   </div> 
   <div class="mobileLogo"></div> 
  </div> 
  <div id="master-wrapper" class="master-wrapper clear"> 
   <div id="sidebar" class="sidebar"> 
    <div class="sidebar-wrap"> 
     <div class="content"> 
      <div class="sidebar-menu"> 
       <div class="toc" id="customScrollbar"> 
        <h2>Manual Unity</h2> 
        <div class="search-form sidebar-search-form"> 
         <form action="30_search.html" method="get" class="apisearch"> 
          <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
          <input type="submit" id="mobileSearchBtn" class="submit" value="Search"> 
         </form> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div id="content-wrap" class="content-wrap"> 
    <div class="content-block"> 
     <div class="content"> 
      <div class="section"> 
       <div class="breadcrumbs clear"> 
        <ul> 
         <li><a href="UnityManual.html">Manual Pengguna Unity 2022.1 (beta)</a></li> 
         <li><a href="UnityOverview.html">Bekerja di Unity</a></li> 
         <li><a href="analysis.html">Analysis</a></li> 
         <li><a href="BestPracticeUnderstandingPerformanceInUnity.html">Memahami optimasi dalam Unity</a></li> 
         <li>Optimasi khusus</li> 
        </ul> 
       </div> 
       <div class="mb20"> 
        <div class="nextprev clear"> 
         <div class="icon tt left mr1" data-distance="-40|-30|top"> 
          <span class="prev"><a href="BestPracticeUnderstandingPerformanceInUnity7.html"></a></span> 
          <div class="tip">
            Optimasi Umum 
          </div> 
         </div> 
         <div class="icon tt right" data-distance="-40|-30|top"> 
          <span class="next"><a href="AsyncReadManagerMetrics.html"></a></span> 
          <div class="tip">
            Aset memuat metrik 
          </div> 
         </div> 
        </div> 
       </div> 
       <div id="_leavefeedback"></div> 
       <h1>Optimasi khusus</h1> 
       <!--BeginSwitchLink--> 
       <!--EndSwitchLink--> 
       <div class="clear"></div> 
       <p>Sementara bagian sebelumnya yang dijelaskan optimasi berlaku untuk semua proyek, optimasi detail bagian ini yang harus <em>not</em> diterapkan sebelum mengumpulkan data profil. Ini mungkin karena optimasi intensif tenaga kerja untuk mengimplementasikan, dapat mempromikan kebersihan kode atau pemeliharaan dalam mendukung kinerja, atau mungkin menyelesaikan masalah yang hanya muncul pada perbesaran skala tertentu.</p> 
       <h2>Multidimensional vs. array bergerigi</h2> 
       <p>Seperti yang dijelaskan dalam <a href="http://stackoverflow.com/questions/597720/what-are-the-differences-between-a-multidimensional-array-and-an-array-of-arrays">StackOverflow artikel</a> ini, umumnya lebih efisien untuk menjauhkan array bergerigi daripada array multidimensi, sebagai array multidimensi memerlukan panggilan fungsi.</p> 
       <p>NOTES:</p> 
       <ul> 
        <li><p>Ini adalah array dari array, dan dinyatakan sebagai <code>type[x][y]</code> bukan <code>type[x,y</code>].)</p></li> 
        <li><p>Ini dapat ditemukan dengan memeriksa IL yang dihasilkan dengan mengakses array multidimensi, menggunakan ILSpy atau alat serupa.)</p></li> 
       </ul> 
       <p>Ketika diprofilkan dalam Unity 5.3, 100 iterasi parsial penuh atas array 100x100x100x100 tiga dimensi menghasilkan waktu berikut, yang rata-rata lebih dari 10 berjalan dari tes:</p> 
       <table> 
        <colgroup> 
         <col style="text-align:left;"> 
         <col style="text-align:left;"> 
        </colgroup> 
        <thead> 
         <tr> 
          <th style="text-align:left;">Jenis Array</th> 
          <th style="text-align:left;">Total waktu (100 iterasi)</th> 
         </tr> 
        </thead> 
        <tbody> 
         <tr> 
          <td style="text-align:left;">Satu Dimensi Login</td> 
          <td style="text-align:left;">660 ms</td> 
         </tr> 
         <tr> 
          <td style="text-align:left;">Jagged Arrays</td> 
          <td style="text-align:left;">730 ms</td> 
         </tr> 
         <tr> 
          <td style="text-align:left;">Array Multidimen</td> 
          <td style="text-align:left;">3470 ms</td> 
         </tr> 
        </tbody> 
       </table> 
       <p>Biaya panggilan fungsi tambahan dapat dilihat dalam keparitas antara biaya akses array multidimensi vs. array satu dimensi, dan biaya iterating atas struktur memori non-tunjuk dapat dilihat dalam perbedaan antara mengakses array bergerigi vs. array satu dimensi.</p> 
       <p>Seperti yang ditunjukkan di atas, biaya fungsi tambahan memanggil sangat melebihi biaya yang dikenakan dengan menggunakan struktur memori yang tidak utuh.</p> 
       <p>Untuk operasi yang sangat sensitif, disarankan untuk menggunakan array satu dimensi. Untuk semua kasus lain di mana array dengan beberapa dimensi diperlukan, gunakan array bergerigi. array multidimensi tidak boleh digunakan.</p> 
       <h2>Sistem Partikel</h2> 
       <p>Ketika memadukan sistem partikel, menyadari bahwa mereka mengkonsumsi setidaknya 3500 byte memori. Konsumsi memori meningkat berdasarkan jumlah modul yang diaktifkan pada <span class="tooltip"><strong>Particle System</strong><span class="tooltiptext">Komponen yang mensimulasikan entitas fluida seperti cairan, awan dan nyala dengan menghasilkan dan memikat sejumlah besar gambar 2D kecil di tempat kejadian. <a class="tooltipMoreInfoLink" href="class-ParticleSystem.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#particlesystem">Glossary</a></span></span></span>. Memori ini adalah <em>not</em> yang dirilis ketika Sistem Partikel dinonaktifkan; Ini hanya dirilis ketika mereka hancur.</p> 
       <p>Sebagai Unity 5.3, sebagian besar pengaturan Sistem Partikel sekarang dapat dimanipulasi pada runtime. Untuk proyek yang harus memadukan sejumlah besar efek partikel yang berbeda, mungkin lebih efisien untuk mengekstrak parameter konfigurasi Sistem Partikel ke kelas atau struktur data-carrier.</p> 
       <p>Ketika efek partikel diperlukan, kolam efek partikel "generic" kemudian dapat memasok objek efek partikel requisite. Data konfigurasi kemudian dapat diterapkan pada objek untuk mencapai efek grafis yang diinginkan.</p> 
       <p>Ini secara substansial lebih hemat memori daripada mencoba untuk memadukan semua kemungkinan varian &amp; konfigurasi Sistem Partikel yang digunakan dalam <span class="tooltip"><strong>Scene</strong><span class="tooltiptext">Adegan berisi lingkungan dan menu permainan Anda. Pikirkan setiap file Adegan unik sebagai tingkat yang unik. Di setiap Adegan, Anda menempatkan lingkungan, hambatan, dan dekorasi, pada dasarnya merancang dan membangun permainan Anda dalam potongan-potongan. <a class="tooltipMoreInfoLink" href="CreatingScenes.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Scene">Glossary</a></span></span></span> tertentu, tetapi memerlukan upaya rekayasa yang substansial untuk mencapai.</p> 
       <h2>Manajer pembaruan</h2> 
       <p>Secara internal, daftar trek Unity objek yang tertarik dengan panggilannya, seperti <code>Update</code>, <code>FixedUpdate</code> dan <code>LateUpdate</code>. Ini dipelihara sebagai daftar yang tidak mengganggu untuk memastikan bahwa pembaruan daftar terjadi pada waktu yang konstan. MonoBehaviours ditambahkan ke / dihapus dari daftar ini ketika mereka Diaktifkan atau Diaktifkan, masing-masing.</p> 
       <p>Meskipun nyaman untuk menambahkan callback yang tepat ke MonoBehaviours yang membutuhkannya, ini menjadi semakin tidak efisien karena jumlah callback tumbuh. Ada overhead kecil namun signifikan untuk memanggil callback kode yang dikelola dari kode asli. Hasil ini baik dalam waktu bingkai yang terdegradasi ketika mengabdikan sejumlah besar metode per-frame, dan dalam waktu sekiasi yang terdegradasi ketika menginisiasi <span class="tooltip"><strong>Prefabs</strong><span class="tooltiptext">Jenis aset yang memungkinkan Anda untuk menyimpan GameObject lengkap dengan komponen dan properti. Prefab bertindak sebagai template dari mana Anda dapat membuat instance objek baru di tempat kejadian. <a class="tooltipMoreInfoLink" href="Prefabs.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Prefab">Glossary</a></span></span></span> yang mengandung sejumlah besar MonoBehaviours (NOTE: Biaya seketika disebabkan oleh overhead kinerja memprovokasi Awake dan callback OnEnable pada setiap Komponen dalam prefab.).</p> 
       <p>Ketika jumlah MonoBehaviours dengan callback per-frame tumbuh menjadi ratusan atau ribuan, itu menguntungkan untuk menghilangkan panggilan ini dan bukan memiliki MonoBehaviours (atau bahkan standar C # objek) melampirkan ke manajer global tunggal. Manajer global singleton kemudian dapat mendistribusikan <code>Update</code>, <code>LateUpdate</code> dan callback lainnya untuk objek yang tertarik. Ini memiliki manfaat tambahan dari memungkinkan kode untuk secara cerdas berhenti berlangganan dari callback ketika mereka tidak akan ada-op, sehingga menyusut jumlah fungsi geser yang harus disebut setiap bingkai.</p> 
       <p>Penghematan terbesar biasanya direalisasikan dengan menghilangkan callback yang jarang dieksekusi. Pertimbangkan kode pseudo-code berikut:</p> 
       <pre><code>void Update() {
    if(!someVeryRareCondition) { return; }
// … some operation …
}
</code></pre> 
       <p>Jika ada sejumlah besar MonoBehaviours dengan Update callback mirip dengan di atas, maka jumlah yang signifikan dari waktu yang dikonsumsi menjalankan callback Update dihabiskan beralih antara domain kode asli dan dikelola untuk eksekusi MonoBehaviour yang kemudian keluar segera. Jika kelas ini bukan berlangganan Manajer Pembaruan global hanya sementara <code>someVeryRareCondition</code> benar, dan berhenti berlangganan setelah itu, waktu akan disimpan kedua switching domain kode dan pada evaluasi kondisi langka.</p> 
       <h3>Menggunakan C# delegasi dalam manajer pembaruan</h3> 
       <p>Ini menggoda untuk menggunakan polos C# delegasi untuk menerapkan callback ini. Namun, implementasi delegasi C# dioptimalkan untuk tarif rendah berlangganan dan berhenti berlangganan, dan untuk jumlah callback rendah. A C # delegate melakukan daftar callback penuh dalam setiap kali callback ditambahkan atau dihapus. Daftar besar callback, atau sejumlah besar callbacks subscribing/unsubscribing selama satu bingkai hasil dalam lonjakan kinerja dalam metode <code>Delegate.Combine</code> internal.</p> 
       <p>Untuk kasus di mana adds/removes terjadi pada frekuensi tinggi, pertimbangkan menggunakan struktur data yang dirancang untuk sisipan cepat / bergerak bukan delegasi.</p> 
       <h2>Memuat kontrol benang</h2> 
       <p>Para pengembang bersatu untuk mengontrol prioritas benang latar belakang yang digunakan untuk memuat data. Hal ini sangat penting ketika mencoba untuk streaming AssetBundles ke disk di latar belakang.</p> 
       <p>Prioritas untuk benang utama dan benang grafis adalah kedua <code>ThreadPriority.Normal</code> - benang apa pun dengan prioritas yang lebih tinggi preempt benang utama / grafik dan menyebabkan kenaikan bingkai, sedangkan benang dengan prioritas yang lebih rendah tidak. Jika benang memiliki prioritas yang setara dengan benang utama, upaya CPU untuk memberikan waktu yang sama dengan benang, yang umumnya menghasilkan stuttering berbingkai jika beberapa benang latar belakang melakukan operasi berat, seperti dekompresi AssetBundle.</p> 
       <p>Saat ini, prioritas ini dapat dikontrol dalam tiga tempat.</p> 
       <p>Pertama, prioritas default untuk panggilan pemuatan Aset, seperti <code>Resources.LoadAsync</code> dan <code>AssetBundle.LoadAssetAsync</code>, diambil dari pengaturan <a href="../ScriptReference/Application-backgroundLoadingPriority.html">Aplikasi.backgroundLoadingPrioritas</a>. Seperti yang didokumentasikan, panggilan ini juga membatasi jumlah waktu bahwa benang utama menghabiskan aset mengintegrasikan (NOTE: Kebanyakan jenis aset Unity harus "diintegrasikan" ke benang utama. Selama integrasi, awalisasi Aset selesai dan operasi keamanan benang tertentu dilakukan. Ini termasuk panggilan balik skrip, seperti panggilan Awake. Lihat panduan “Resource Management” untuk rincian lebih lanjut.), untuk membatasi dampak pemuatan Aset pada waktu bingkai.</p> 
       <p>Kedua, setiap asinkron Operasi pemuatan aset, serta setiap permintaan UnityWebRequest, mengembalikan objek <code>AsyncOperation</code> untuk memantau dan mengelola operasi. Objek <code>AsyncOperation</code> ini mengekspos properti <a href="../ScriptReference/AsyncOperation-priority.html">priority</a> yang dapat digunakan untuk mengubah prioritas operasi individu.</p> 
       <p>Akhirnya, www objek, seperti yang dikembalikan dari panggilan ke <code>WWW.LoadFromCacheOrDownload</code>, mengekspos properti <a href="../ScriptReference/WWW-threadPriority.html">Login Login</a>. Penting untuk dicatat bahwa objek WWW tidak secara otomatis menggunakan pengaturan <code>Application.backgroundLoadingPriority</code> sebagai nilai default mereka - objek WWW selalu default ke <code>ThreadPriority.Normal</code>.</p> 
       <p>Penting untuk dicatat bahwa sistem di bawah tanah yang digunakan untuk menekan dan memuat data berbeda antara API ini. <code>Resources.LoadAsync</code> dan <code>AssetBundle.LoadAssetAsync</code> dioperasikan oleh sistem PreloadManager internal Unity, yang mengatur utas pemuatan sendiri (s) dan melakukan penilaian tingkat sendiri. <code>UnityWebRequest</code> menggunakan kolam benang khususnya sendiri. <code>WWW</code> spawns benang yang sepenuhnya baru setiap kali permintaan dibuat.</p> 
       <p>Sementara semua mekanisme pemuatan lainnya memiliki sistem queuing bawaan, www tidak. Memanggil <code>WWW.LoadFromCacheOrDownload</code> pada sejumlah besar Aset Terkompresi Memijat sejumlah benang yang setara, yang kemudian bersaing dengan benang utama untuk waktu CPU. Ini dapat dengan mudah mengakibatkan stuttering frame-rate.</p> 
       <p>Oleh karena itu, ketika menggunakan www untuk memuat dan mendekompresi AssetBundles, dianggap sebagai praktik terbaik untuk menetapkan nilai yang tepat untuk <code>threadPriority</code> dari setiap objek WWW yang diciptakan.</p> 
       <h2>Gerakan objek massa &amp; CullingGroups</h2> 
       <p>Seperti yang disebutkan di bagian Transform Manipulasi, bergerak hierarki Transform besar memiliki biaya CPU yang relatif tinggi karena perbanyakan pesan perubahan. Namun, dalam lingkungan pembangunan nyata, seringkali tidak mungkin untuk runtuh hirarki ke sejumlah sederhana <span class="tooltip"><strong>GameObjects</strong><span class="tooltiptext">Objek mendasar dalam adegan Unity, yang dapat mewakili karakter, props, pemandangan, kamera, waypoints, dan banyak lagi. Fungsi GameObject didefinisikan oleh Komponen yang melekat padanya. <a class="tooltipMoreInfoLink" href="class-GameObject.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#GameObject">Glossary</a></span></span></span>.</p> 
       <p>Pada saat yang sama, itu adalah praktik pengembangan yang baik untuk hanya menjalankan perilaku yang cukup untuk mempertahankan kecayaan dunia permainan sambil menghilangkan perilaku pengguna tidak akan memperhatikan - misalnya, dalam Adegan dengan sejumlah besar karakter, selalu lebih optimal untuk hanya menjalankan gerakan Transformasi Mesh-skinning dan animasi-driven untuk karakter yang ada di layar. Tidak ada alasan untuk membuang waktu CPU menghitung elemen visual murni dari simulasi untuk karakter yang off-screen.</p> 
       <p>Kedua masalah ini dapat ditangani secara rapi dengan API pertama kali diperkenalkan dalam Unity 5.1: <a href="CullingGroupAPI.html">CullingGroups</a>.</p> 
       <p>Alih-alih langsung memanipulasi sekelompok besar GameObjects di tempat kejadian, mengubah sistem untuk memanipulasi parameter vektor3 dari sekelompok BoundingSpheres dalam CullingGroup. Setiap Bounding Sphere berfungsi sebagai repositori otoritatif untuk posisi dunia-space entitas permainan tunggal, dan menerima callback ketika entitas bergerak dekat/dalam frustum dari CullingGroup's main <span class="tooltip"><strong>camera</strong><span class="tooltiptext">Komponen yang menciptakan gambar sudut pandang tertentu di tempat kejadian Anda. Output ditarik ke layar atau ditangkap sebagai tekstur. <a class="tooltipMoreInfoLink" href="CamerasOverview.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Camera">Glossary</a></span></span></span>. Panggilan ini kemudian dapat digunakan untuk mengaktifkan / menonaktifkan kode atau komponen (seperti Animators) mengatur perilaku yang hanya harus dijalankan sementara entitas terlihat.</p> 
       <h2>Mengurangi metode memanggil overhead</h2> 
       <p>Perpustakaan string C# menyediakan studi kasus yang sangat baik dalam biaya menambahkan metode tambahan panggilan ke kode perpustakaan sederhana. Dalam bagian pada API string built-in <code>String.StartsWith</code> dan <code>String.EndsWith</code>, disebutkan bahwa penggantian yang dikodekan tangan adalah 10-100 kali lebih cepat daripada metode built-in, bahkan ketika coercion lokal yang tidak diinginkan ditekan.</p> 
       <p>Alasan utama untuk perbedaan kinerja ini hanya biaya menambahkan metode tambahan panggilan ke loop dalam yang ketat. Setiap metode yang diinvokasi harus menemukan alamat metode dalam memori dan mendorong bingkai lain ke tumpukan. Baik dari operasi ini gratis, tetapi sebagian besar kode mereka cukup kecil untuk mengabaikan.</p> 
       <p>Namun, ketika menjalankan metode kecil dalam loop ketat, overhead ditambahkan dengan memperkenalkan panggilan metode tambahan dapat menjadi signifikan - dan bahkan dominan.</p> 
       <p>Pertimbangkan dua metode sederhana berikut.</p> 
       <p><strong>Example 1:</strong></p> 
       <pre><code>int Accum { get; set; }
Accum = 0;

for(int i = 0; i &lt; myList.Count; i++) {
    Accum += myList[i];
}

</code></pre> 
       <p><strong>Example 2:</strong></p> 
       <pre><code>int accum = 0;
int len = myList.Count;

for(int i = 0; i &lt; len; i++) {
    accum += myList[i];
}
</code></pre> 
       <p>Kedua metode menghitung jumlah semua bilangan bulat dalam C # generik <code>List&lt;int&gt;</code>. Contoh pertama adalah sedikit lebih "modern C#" di mana ia menggunakan properti yang dihasilkan secara otomatis untuk menahan nilai datanya.</p> 
       <p>Sementara di permukaan dua buah kode muncul setara, perbedaannya tidak dapat dianalisis ketika kode dianalisis untuk panggilan metode.</p> 
       <p><strong>Example 1:</strong></p> 
       <pre><code>int Accum { get; set; }
Accum = 0;

for(int i = 0;
       i &lt; myList.Count;    // call to List::getCount
       i++) {
    Accum       // call to set_Accum
+=      // call to get_Accum
myList[i];  // call to List::get_Value
}
</code></pre> 
       <p>Jadi ada empat metode memanggil setiap kali loop mengeksekusi:</p> 
       <ul> 
        <li> <code>myList.Count</code> memanggil metode <code>get</code> pada properti <code>Count</code> property</li> 
        <li>Metode <code>get</code> dan <code>set</code> pada properti <code>Accum</code> harus disebut</li> 
        <li> <code>get</code> untuk mengambil nilai saat ini <code>Accum</code> sehingga dapat dilewatkan ke operasi tambahan</li> 
        <li> <code>set</code> untuk menetapkan hasil operasi tambahan hingga <code>Accum</code> </li> 
        <li>Operator <em>[]</em> memanggil metode <em>Login Login</em> daftar untuk mengambil nilai item pada indeks tertentu pada daftar.</li> 
       </ul> 
       <p><strong>Example 2:</strong></p> 
       <pre><code>int accum = 0;
int len = myList.Count;

for(int i = 0;
    i &lt; len; 
    i++) {
    accum += myList[i]; // call to List::get_Value
}
</code></pre> 
       <p>Dalam contoh kedua ini, panggilan ke <code>get_Value</code> tetap, tetapi semua metode lain telah dihilangkan atau tidak lagi mengeksekusi sekali per lingkaran iterasi.</p> 
       <ul> 
        <li><p>Seperti <code>accum</code> sekarang nilai primitif bukan properti, panggilan metode tidak perlu dibuat untuk mengatur atau mengambil nilainya.</p></li> 
        <li><p>Sebagai <code>myList.Count</code> diasumsikan untuk tidak bervariasi sementara loop berjalan, aksesnya telah dipindahkan di luar pernyataan kondisi loop, sehingga tidak lagi dieksekusi pada awal setiap iterasi loop.</p></li> 
       </ul> 
       <p>Waktu untuk dua versi mengungkapkan manfaat sebenarnya dari menghapus 75% metode memanggil overhead dari cuplikan kode tertentu ini. Ketika menjalankan 100.000 kali pada mesin desktop modern:</p> 
       <ul> 
        <li>Contoh 1 membutuhkan 324 mili detik untuk melaksanakan</li> 
        <li>Contoh 2 membutuhkan 128 mili detik untuk melaksanakan</li> 
       </ul> 
       <p>Masalah utama di sini adalah bahwa Unity melakukan inlining metode yang sangat sedikit, jika ada. Bahkan di bawah <span class="tooltip"><strong>IL2CPP</strong><span class="tooltiptext">Back-end scripting bersatu yang dapat Anda gunakan sebagai alternatif untuk Mono ketika proyek bangunan untuk beberapa platform. <a class="tooltipMoreInfoLink" href="IL2CPP.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#IL2CPP">Glossary</a></span></span></span>, banyak metode tidak saat ini masuk dengan benar. Ini terutama berlaku dari properti. Selanjutnya, metode <em>virtual</em> dan antarmuka tidak dapat dilinasi sama sekali.</p> 
       <p>Oleh karena itu, panggilan metode dinyatakan dalam sumber C# sangat mungkin untuk akhirnya menghasilkan panggilan metode dalam aplikasi biner akhir.</p> 
       <h3>Trivial properti</h3> 
       <p>Unity menyediakan banyak “sederhana” konstan pada jenis datanya untuk kenyamanan pengembang. Namun, dalam cahaya di atas, penting untuk dicatat bahwa konstanta ini umumnya diterapkan sebagai sifat yang mengembalikan nilai-nilai konstan.</p> 
       <p>Tubuh properti vektor3.zero adalah sebagai berikut:</p> 
       <pre><code>get { return new Vector3(0,0,0); }
</code></pre> 
       <p>Quaternion.identitas sangat mirip:</p> 
       <pre><code>get { return new Quaternion(0,0,0,1); }

</code></pre> 
       <p>Sementara biaya mengakses properti ini biasanya kecil dibandingkan dengan kode sebenarnya di sekitarnya, mereka dapat membuat perbedaan kecil ketika mereka dieksekusi ribuan kali per bingkai (atau lebih).</p> 
       <p>Untuk jenis primitif sederhana, gunakan nilai <code>const</code> sebagai gantinya. Nilai <code>Const</code> dilinasi pada waktu kompilasi - referensi ke variabel <code>const</code> diganti dengan nilainya.</p> 
       <p>Sitemap Karena setiap referensi ke variabel <strong>Note:</strong> diganti dengan nilainya, tidak dapat diinformasikan untuk menyatakan string panjang atau jenis data besar lainnya <code>const</code>. Ini tidak perlu bloat ukuran biner akhir karena semua data duplicated dalam kode instruksi akhir.<code>const</code>. This unnecessarily bloats the size of the final binary due to all the duplicated data in the final instruction code.</p> 
       <p>Dimanapun <code>const</code> tidak tepat, buat variabel <code>static readonly</code> bukan. Dalam beberapa proyek, bahkan properti sepele bawaan Unity telah diganti dengan variabel <code>static readonly</code>, menghasilkan peningkatan kecil dalam kinerja.</p> 
       <h3>Trivial metode</h3> 
       <p>Metode trivial lebih rumit. Sangat berguna untuk dapat menyatakan fungsi sekali dan menggunakannya di tempat lain. Namun, dalam lingkaran bagian dalam yang ketat, mungkin perlu untuk berangkat dari praktik pengkodean yang baik dan bukan kode tertentu “secara umum”.</p> 
       <p>Beberapa metode dapat dihilangkan langsung. Pertimbangkan <code>Quaternion.Set</code>, <code>Transform.Translate</code> atau <code>Vector3.Scale</code>. Ini melakukan operasi yang sangat sepele dan dapat diganti dengan pernyataan tugas sederhana.</p> 
       <p>Untuk metode yang lebih kompleks, beratkan bukti profil untuk inlining manual terhadap biaya jangka panjang menjaga kode yang lebih sesuai.</p> 
       <!-- area:core --> 
       <div id="_content"></div> 
       <div class="nextprev clear"> 
        <div class="icon tt left mr1" data-distance="-40|-30|top"> 
         <span class="prev"><a href="BestPracticeUnderstandingPerformanceInUnity7.html"></a></span> 
         <div class="tip">
           Optimasi Umum 
         </div> 
        </div> 
        <div class="icon tt right" data-distance="-40|-30|top"> 
         <span class="next"><a href="AsyncReadManagerMetrics.html"></a></span> 
         <div class="tip">
           Aset memuat metrik 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="footer-wrapper"> 
       <div class="footer clear"> 
        <div class="copy">
          © 2022 Unity Technologies. Tanggal Publikasi: 2022-04-04. 
        </div> 
        <div class="menu"> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div>  
 </body>
</html>
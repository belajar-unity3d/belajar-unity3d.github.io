<!doctype html>
<html lang="en" class="no-js">
 <head> 
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> 
  <script type="text/javascript" src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" charset="UTF-8" data-domain-script="6e91be4c-3145-4ea2-aa64-89d716064836"></script> 
  <script type="text/javascript">
					function OptanonWrapper() { }
				</script> 
  <script>var offline=false;if(!offline){(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);  })(window,document,'script','dataLayer','GTM-K8K24X8');}</script> 
  <link href="https://fonts.googleapis.com/css?family=Roboto&amp;display=swap" rel="stylesheet"> 
  <meta charset="utf-8"> 
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <title>XR SDK Database</title> 
  <meta property="og:image" content="https://unity3d.com/files/images/ogimg.jpg"> 
  <meta name="author" content="Unity Technologies"> 
  <link rel="shortcut icon" href="https://unity.com/themes/contrib/unity_base/images/favicons/favicon.ico"> 
  <link rel="icon" type="image/png" href="../StaticFilesManual/images/favicons/favicon.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../StaticFilesManual/images/favicons/apple-touch-icon-152x152.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../StaticFilesManual/images/favicons/apple-touch-icon-144x144.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="../StaticFilesManual/images/favicons/apple-touch-icon-120x120.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../StaticFilesManual/images/favicons/apple-touch-icon-114x114.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../StaticFilesManual/images/favicons/apple-touch-icon-72x72.png"> 
  <link rel="apple-touch-icon-precomposed" href="../StaticFilesManual/images/favicons/apple-touch-icon.png"> 
  <meta name="msapplication-TileColor" content="#222c37"> 
  <meta name="msapplication-TileImage" content="../StaticFilesManual/images/favicons/tileicon-144x144.png"> 
  <script type="text/javascript" src="https://docs.unity3d.com/StaticFilesConfig/UnityVersionsInfo.js"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/jquery.js?ts=20220404"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/core.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/toc.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/global_toc.js?ts=20220404"></script> 
  <link rel="stylesheet" type="text/css" href="../StaticFilesManual/css/core.css?ts=20220404"> 
  <link rel="stylesheet" href="../StaticFilesManual/css/prism.css"> 
  <script src="../StaticFilesManual/js/prism.js"></script> 
  <script src="/StaticFilesConfig/feedback/feedback.js"></script> 
  <script src="../StaticFilesManual/js/jquery.sidebar.min.js"></script> 
  <link rel="stylesheet" href="../StaticFilesManual/css/mobileoptimisation.css"> 
  <script src="../StaticFilesManual/js/mobileoptimisation.js"></script> 
 </head> 
 <body> 
  <noscript> 
   <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K8K24X8" height="0" width="0" style="display:none;visibility:hidden"></iframe> 
  </noscript> 
  <div id="DocsAnalyticsData" data-area="platforms" data-pagetype="manual"></div> 
  <div class="header-wrapper"> 
   <div id="header" class="header"> 
    <div class="content"> 
     <div class="spacer"> 
      <div class="menu"> 
       <div id="nav-open" for="nav-input"> 
        <span></span> 
       </div> 
       <div class="logo"></div> 
       <div class="search-form"> 
        <form action="30_search.html" method="get" class="apisearch"> 
         <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
         <input type="submit" class="submit"> 
        </form> 
       </div> 
       <ul> 
        <li><a href="../Manual/index.html" class="selected">Manual</a></li> 
        <li><a href="../ScriptReference/index.html">API documentation</a></li> 
       </ul> 
      </div> 
     </div> 
     <div class="more"> 
      <div class="filler"></div> 
      <ul> 
       <li></li> 
      </ul> 
     </div> 
    </div> 
   </div> 
   <div class="toolbar"> 
    <div class="content"> 
    </div> 
   </div> 
   <div class="mobileLogo"></div> 
  </div> 
  <div id="master-wrapper" class="master-wrapper clear"> 
   <div id="sidebar" class="sidebar"> 
    <div class="sidebar-wrap"> 
     <div class="content"> 
      <div class="sidebar-menu"> 
       <div class="toc" id="customScrollbar"> 
        <h2>Manual Unity</h2> 
        <div class="search-form sidebar-search-form"> 
         <form action="30_search.html" method="get" class="apisearch"> 
          <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
          <input type="submit" id="mobileSearchBtn" class="submit" value="Search"> 
         </form> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div id="content-wrap" class="content-wrap"> 
    <div class="content-block"> 
     <div class="content"> 
      <div class="section"> 
       <div class="breadcrumbs clear"> 
        <ul> 
         <li><a href="UnityManual.html">Unity User Manual 2022.1 (beta)</a></li> 
         <li><a href="XR.html">XR</a></li> 
         <li><a href="xr-sdk.html">SDK</a></li> 
         <li>Subsystems</li> 
         <li>XR SDK</li> 
        </ul> 
       </div> 
       <div class="mb20"> 
        <div class="nextprev clear"> 
         <div class="icon tt left mr1" data-distance="-40|-30|top"> 
          <span class="prev"><a href="xrsdk-input.html"></a></span> 
          <div class="tip">
            SDK Subsistem masukan 
          </div> 
         </div> 
         <div class="icon tt right" data-distance="-40|-30|top"> 
          <span class="next"><a href="xrsdk-meshing.html"></a></span> 
          <div class="tip">
            SDK Sitemap 
          </div> 
         </div> 
        </div> 
       </div> 
       <div id="_leavefeedback"></div> 
       <h1>XR SDK</h1> 
       <!--BeginSwitchLink--> 
       <!--EndSwitchLink--> 
       <div class="clear"></div> 
       <p>Subsistem Display SDK XR menyediakan antarmuka untuk alokasi tekstur, siklus hidup bingkai, dan memblokir untuk kader.</p> 
       <h2>Alokasi Tekstur</h2> 
       <p>Beberapa perangkat SDK membutuhkan tekstur yang dialokasikan melalui SDK sendiri daripada API grafis yang biasa. Jika Anda menggunakan subsistem Display SDK XR, Anda tidak perlu lagi mengandalkan <span class="tooltip"><strong>plug-ins</strong><span class="tooltiptext">Satu set kode yang dibuat di luar Unity yang menciptakan fungsi dalam Unity. Ada dua jenis plug-ins yang dapat Anda gunakan di Unity: Managed plug-ins (diproduksi. Rakitan NET dibuat dengan alat-alat seperti Studio Visual) dan plug-ins asli (pustaka kode asli yang spesifik platform). <a class="tooltipMoreInfoLink" href="Plugins.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Plug-in">Glossary</a></span></span></span> eksternal untuk <span class="tooltip"><strong>blit</strong><span class="tooltiptext">Jangka waktu singkat untuk transfer blok "bit". Pengoperasian yang mudah adalah proses mentransfer blok data dari satu tempat dalam memori ke yang lain.<br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#blit">Glossary</a></span></span></span> atau menyalin ke dalam tekstur SDK.</p> 
       <p>Subsistem tampilan memungkinkan penyedia plug-in untuk mengalokasikan tekstur. Bila memungkinkan, render Unity langsung ke tekstur untuk menghindari salinan yang tidak perlu. Unity juga dapat mengalokasikan tekstur untuk Anda jika diperlukan.</p> 
       <p>Dalam kasus-kasus berikut, Unity tidak dapat membuat langsung ke tekstur dan bukan render ke tekstur menengah dan kemudian menyalakan atau menyalin ke tekstur Anda:</p> 
       <ul> 
        <li>Jika efek gambar digunakan, tekstur Anda akan berlangsung di rantai.</li> 
        <li>Pada PC dengan MSAA, render Unity ke tekstur multisampled dan kemudian menyelesaikan tekstur Anda pada akhir tumpukan <span class="tooltip"><strong>camera</strong><span class="tooltiptext">Komponen yang menciptakan gambar sudut pandang tertentu di tempat kejadian Anda. Output ditarik ke layar atau ditangkap sebagai tekstur. <a class="tooltipMoreInfoLink" href="CamerasOverview.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Camera">Glossary</a></span></span></span>.</li> 
        <li>Di ponsel, dengan ekstensi menyelesaikan otomatis multisample, tekstur akan sangat diselesaikan ketika tekstur dibilas atau digunakan sebagai sumber atau tujuan untuk operasi apa pun selain menggambarnya. Lihat ekstensi <code>EXT_multisampled_render_to_texture</code>.</li> 
        <li>Mempertahankan rendering, <span class="tooltip"><strong>HDR</strong><span class="tooltiptext">kisaran dinamis tinggi<br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#HDR">Glossary</a></span></span></span>, dan penyangga perintah menyebabkan Unity untuk membuat tekstur menengah.</li> 
        <li>Jika rendering ke subset layar, render Unity untuk tekstur menengah.</li> 
        <li>Jika “ketelemen tekstur” tidak sesuai dengan apa Unity rendering ke (misalnya, Unity rendering setiap mata untuk tekstur terpisah, tetapi RenderPass dikonfigurasi untuk membuat array tekstur atau tekstur tunggal).</li> 
        <li>Jika bendera <code>kUnityXRRenderTextureFlagsLockedWidthHeight</code> ditetapkan dan renderScale tidak 1.0.</li> 
        <li>Jika bendera <code>kUnityXRRenderTextureFlagsWriteOnly</code> ditetapkan dan kebutuhan Unity untuk membaca kembali dari tekstur.</li> 
       </ul> 
       <h3>MSAA</h3> 
       <p>Pada PC dan ponsel, mesin selalu menyelesaikan tekstur penyedia. Mesin ini melakukan penyelesaian implicit (di ponsel dengan render multi-sample untuk ekstensi tekstur) atau menyelesaikan eksplisit.</p> 
       <p>Di ponsel, penyedia harus mengaktifkan bendera <code>kUnityXRRenderTextureFlagsAutoResolve</code> dan membuat tekstur mereka dengan 1 sampel.</p> 
       <h3>sRGB</h3> 
       <p>Gunakan <code>UnityXRFrameSetupHints.appSetup.sRGB</code> untuk memeriksa apakah Unity mengharapkan untuk membuat format tekstur sRGB. Penyedia akhirnya memilih output <span class="tooltip"><strong>texture format</strong><span class="tooltiptext">Format file untuk menangani tekstur selama rendering real-time oleh perangkat keras grafis 3D, seperti kartu grafis atau perangkat seluler. <a class="tooltipMoreInfoLink" href="class-TextureImporterOverride.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#TextureFormat">Glossary</a></span></span></span> dari bidang <code>colorFormat</code> <code>UnityXRRenderTextureDesc</code>. Jika format adalah tipe sRGB, Unity mengubah sRGB menulis pada atau off tergantung pada ruang warna yang dipilih proyek aktif. Anda harus selalu sampel dari setiap tekstur sRGB dengan sRGB ke konversi linier di compositor Anda.</p> 
       <h3>Tekstur kedalaman</h3> 
       <p>Jika SDK Anda membutuhkan informasi mendalam, Anda dapat memperoleh <span class="tooltip"><strong>depth buffer</strong><span class="tooltiptext">Sebuah toko memori yang memegang kedalaman nilai z setiap pixel dalam gambar, di mana nilai z adalah kedalaman untuk setiap piksel yang diberikan dari pesawat proyeksi. <a class="tooltipMoreInfoLink" href="class-RenderTexture.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#depthbuffer">Glossary</a></span></span></span> dengan cara yang sama seperti buffer warna di atas. Nilai <code>nativeDepthTex</code> pada <code>UnityXRRenderTextureDesc</code> menentukan sumber daya asli. Secara default, Unity mencoba untuk berbagi penyangga kedalaman antara tekstur dengan desc yang mirip jika <code>nativeDepthTex</code> diatur ke <code>kUnityXRRenderTextureIdDontCare</code>.</p> 
       <p>Jika SDK Anda tidak memerlukan informasi mendalam, Anda harus mengatur <code>UnityXRRenderTextureDesc::depthFormat</code> ke <code>kUnityXRDepthTextureFormatNone</code> untuk menghindari penyelesaian yang tidak perlu.</p> 
       <h3>Penanganan penyangga ganda dan triple</h3> 
       <p>Selama pengajuan (lihat bagian <a href="#submitting-frames-in-flight">Mengirimkan bingkai dalam lampu</a> di bawah), Anda dapat menentukan ID tekstur yang berbeda setiap bingkai untuk menangani kasus di mana SDK perlu gambar dua atau tiga-buffer yang disatukan. Penyedia plug-in bertanggung jawab untuk mengelola koleksi <code>UnityXRRenderTextureId</code>s.</p> 
       <h2>Bingkai siklus hidup</h2> 
       <p>Ada dua metode yang bertanggung jawab untuk siklus hidup bingkai: <code>PopulateNextFrameDesc</code>, yang terjadi tepat sebelum rendering dimulai, dan <code>SubmitCurrentFrame</code>, yang terjadi segera setelah rendering selesai. Kedua metode yang disebut pada benang grafis.</p> 
       <p>Selama <code>PopulateNextFrameDesc</code>, penyedia tampilan diharapkan untuk melakukan hal berikut:</p> 
       <ul> 
        <li>Wait untuk kader (wait sampai Unity harus mulai mengirimkan perintah rendering lagi). Atau, ini dapat dilakukan dalam <code>SubmitCurrentFrame</code>.</li> 
        <li>Mengakuisisi gambar berikutnya dan memberitahukan Unity apa tekstur ID untuk membuat ke depan melalui parameter <code>nextFrame</code>.</li> 
       </ul> 
       <p>Selama metode <code>SubmitCurrentFrame</code>, penyedia tampilan diharapkan untuk melakukan berikut:</p> 
       <ul> 
        <li>Submit bingkai terakhir dalam lampu (misalnya, tekstur mata atau tekstur kedalaman) untuk ditampilkan di layar.</li> 
        <li>Wait untuk kader, sebagai alternatif untuk menunggu selama <code>PopulateNextFrameDesc</code>.</li> 
       </ul> 
       <h3>Memblokir kader</h3> 
       <p>Untuk menjaga latency dan throughput maksimal mungkin ketika rendering ke tampilan HMD, Anda perlu memastikan waktu yang tepat ketika Anda memperoleh pos dan menyerahkan tekstur. Masing-masing HMD memiliki tingkat refresh asli yang komositor mereka berjalan. Mengirimkan lebih cepat daripada hasil tingkat dalam pengalaman sub-optimal karena waktu atau pekerjaan yang tidak tertandingi.</p> 
       <p>Unity mengharapkan penyedia tampilan untuk memblokir, atau menunggu bingkai kader, selama siklus hidup bingkai. Unity mulai mengirimkan perintah rendering sesaat setelah 'menunggu' dari panggilan pemblokiran. Anda harus menyinkronkan waktu bangun ke kompor Anda dalam jendela tertentu. Beberapa SDK menyediakan jendela waktu bangun yang mengambang berdasarkan heuristik. Oculus memanggil ini “queue depan” (lihat <a href="https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-render/?locale=en_US#adaptive-queue-ahead">Dokumentasi pengembang Oculus</a> untuk informasi lebih lanjut). Valve menyebutnya “running start” (lihat slide 18 dan 19 <a href="http://media.steampowered.com/apps/valve/2015/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf">presentasi ini</a>).</p> 
       <p>Unity menunggu siklus hidup bingkai untuk menyelesaikan sebelum mulai mengirimkan perintah grafis pose-dependent.</p> 
       <h4>Dimana menunggu kader</h4> 
       <p>Penyedia dapat menunggu kader baik di <code>PopulateNextFrameDesc</code> atau di <code>SubmitCurrentFrame</code>.</p> 
       <p>Sementara Unity menyerahkan perintah grafis untuk bingkai pada benang grafis, loop simulasi bingkai berikutnya berjalan pada benang utama. Ini mengandung fisika, logika skrip, dll. <code>PopulateNextFrameDesc</code> disebut pada benang grafis setelah semua perintah rendering telah diserahkan, dan hanya setelah simulasi bingkai berikutnya dan semua pekerjaan grafis yang dijadwalkan di dalamnya selesai. Salah satu pekerjaan grafis yang menunggu <code>PopulateNextFrameDesc</code> adalah <code>SubmitCurrentFrame</code> untuk bingkai saat ini. Inilah sebabnya mengapa hal ini berlaku untuk menunggu kader di <code>SubmitCurrentFrame</code>. Selanjutnya, Unity tidak mulai rendering sampai <code>PopulateNextFrameDesc</code> selesai.</p> 
       <p>Dengan rincian ini dalam pikiran, ada beberapa trade-offs untuk menunggu kader di <code>SubmitCurrentFrame</code> bertentangan dengan <code>PopulateNextFrameDesc</code>. Misalnya, menunggu kader di <code>SubmitCurrentFrame</code> dapat menyebabkan masalah kinerja jika jadwal aplikasi pekerjaan grafis mahal selama simulasi. Karena <code>SubmitCurrentFrame</code> dijadwalkan dijalankan setelah rendering, pekerjaan grafis yang aplikasi dijadwalkan akan berjalan setelah <code>SubmitCurrentFrame</code>, tetapi sebelum <code>PopulateNextFrameDesc</code>. Dalam hal ini, penyedia menunggu di <code>SubmitCurrentFrame</code>, kemudian bangun mengharapkan Unity untuk memulai rendering. Namun, Unity memproses pekerjaan grafis aplikasi yang dijadwalkan sebelum panggilan <code>PopulateNextFrameDesc</code>, yang pada gilirannya memungkinkan Unity untuk memulai rendering. Keterlambatan ini antara bangun untuk rendering dan memproses pekerjaan grafis yang dijadwalkan dalam metode pembaruan dapat menyebabkan latency. Pengembang dapat mengoptimalkan ini dengan menjadwalkan pekerjaan grafis mereka <a href="../ScriptReference/MonoBehaviour.OnPostRender.html">setelah rendering</a> untuk memastikan pekerjaan grafis dijadwalkan sebelum <code>SubmitCurrentFrame</code>.</p> 
       <p>Sementara Penyedia menunggu kader di <code>SubmitCurrentFrame</code> memungkinkan komputasi pekerjaan grafis untuk berjalan sejajar dengan benang utama, menunggu kader di blok <code>PopulateNextFrameDesc</code> benang utama Unity sepenuhnya. Ini diterima karena simulasi dan pekerjaan grafis lainnya telah selesai. Masalah mungkin terjadi ketika benang simulasi atau grafis memakan waktu terlalu banyak dan melebihi tingkat bingkai target perangkat. Hal ini dapat menyebabkan tingkat bingkai dipotong setengah sementara <code>PopulateNextFrameDesc</code> menunggu siklus berikutnya dalam kader.</p> 
       <h3>Mengirimkan bingkai dalam lampu</h3> 
       <p>Ketika Unity panggilan <code>SubmitCurrentFrame</code>, tekstur yang telah Anda mendirikan bingkai terakhir telah diberikan kepada, atau Unity telah mengirimkan perintah render ke driver grafis untuk membuat mereka. Unity sekarang dilakukan dengan mereka dan Anda dapat melewatinya ke compositor Anda.</p> 
       <h3>Mengisi descriptor bingkai berikutnya</h3> 
       <p>Setelah memblokir atau memperoleh bingkai berikutnya untuk membuat, Anda harus memberi tahu Unity yang tekstur untuk render ke dalam bingkai berikutnya, dan apa tata letak dari render pass (lihat Render Passes di bawah).</p> 
       <h4>Render passes</h4> 
       <p>Sebuah <code>UnityXRRenderPass</code> dapat melibatkan lulusan dan traversal graf <span class="tooltip"><strong>scene</strong><span class="tooltiptext">Adegan berisi lingkungan dan menu permainan Anda. Pikirkan setiap file Adegan unik sebagai tingkat yang unik. Di setiap Adegan, Anda menempatkan lingkungan, hambatan, dan dekorasi, pada dasarnya merancang dan membangun permainan Anda dalam potongan-potongan. <a class="tooltipMoreInfoLink" href="CreatingScenes.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Scene">Glossary</a></span></span></span>. Ini adalah operasi intensif sumber daya, dan Anda harus mencoba untuk membatasi jumlah kali Unity melakukannya melalui trik seperti rendering tunggal.</p> 
       <p>Setiap <code>UnityXRRenderPass</code> mengandung tekstur output (yang dapat menjadi array tekstur), dan output <code>UnityXRRenderParams</code> seperti tampilan, matriks proyeksi, dan rect untuk membuat atau irisan array tekstur.</p> 
       <p>Untuk setiap bingkai, penyedia tampilan mengatur <code>UnityXRRenderPass</code> dan mengisi <code>UnityXRRenderTextureId</code> yang Unity akan membuat bingkai berikutnya.</p> 
       <p>Gunakan kasus untuk <code>UnityXRRenderPass</code> termasuk berikut:</p> 
       <ul> 
        <li>Dua potong stereo rendering (2 RenderPass x 1 RenderParams)</li> 
        <li>Satu lulus stereo rendering (1 RenderPass x 2 RenderParams)</li> 
       </ul> 
       <p>API mendukung kasus tambahan ini (tetapi Unity mungkin tidak bereaksi dengan benar sekarang):</p> 
       <ul> 
        <li><span class="tooltip"><strong>Quad</strong><span class="tooltiptext">Objek primitif yang menyerupai pesawat tetapi tepinya hanya satu unit panjang, hanya menggunakan 4 simpul, dan permukaan berorientasi pada pesawat XY ruang koordinat lokal. <a class="tooltipMoreInfoLink" href="PrimitiveObjects.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Quad">Glossary</a></span></span></span> melewati rendering stereo FOV lebar (4 RenderPass x 1 RenderParams)</li> 
        <li>Satu lulus + lebar FOV stereo rendering (1 RenderPass x 2 RenderParams + 2 RenderPass x 1 RenderParams)</li> 
        <li>rendering di atas: 
         <ul> 
          <li>Dua tekstur terpisah untuk setiap mata (di dalam dan luar)</li> 
          <li>Satu tekstur, pemasangan UV</li> 
         </ul> </li> 
        <li>skenario pandangan eksternal (HoloLens BEV, mata 3 Mayo) (extra RenderPass)</li> 
        <li>Dekat / jauh rendering untuk membandingkan objek atau orang-orang di tempat kejadian (2 RenderPass, proyeksi yang berbeda, target yang berbeda)</li> 
       </ul> 
       <p>Aman untuk membuat asumsi ini:</p> 
       <ul> 
        <li>Satu tekstur per lulus (singlepass adalah satu tekstur-array)</li> 
        <li>Jika single-pass, dua pose / proyeksi per lulus (atau rendering foveated)</li> 
       </ul> 
       <p>Sitemap Proyek Unity dan XR SDK harus menggunakan pengaturan yang sama (diaktifkan / dinonaktifkan) untuk rendering tunggal-pass, karena pengaturan ini mempengaruhi pengguna <strong>Note:</strong>. Untuk memeriksa apakah rendering tunggal diaktifkan, gunakan <span class="tooltip"><strong>shaders</strong><span class="tooltiptext">Program yang berjalan di GPU. <a class="tooltipMoreInfoLink" href="Shaders.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Shader">Glossary</a></span></span></span>.<code>UnityXRFrameSetupHints.appSetup.singlePassRendering</code>.</p> 
       <h4>Culling passes</h4> 
       <p>Dua rendering pass dapat berbagi lulusan jika <code>cullingPassIndex</code>s mereka diatur ke nilai yang sama. <code>cullingPassIndex</code> memilih yang <code>UnityXRCullingPass</code> untuk digunakan. Melawan melewati harus diisi dalam <code>UnityXRNextFrameDesc</code>.</p> 
       <!-- area:platforms --> 
       <div id="_content"></div> 
       <div class="nextprev clear"> 
        <div class="icon tt left mr1" data-distance="-40|-30|top"> 
         <span class="prev"><a href="xrsdk-input.html"></a></span> 
         <div class="tip">
           SDK Subsistem masukan 
         </div> 
        </div> 
        <div class="icon tt right" data-distance="-40|-30|top"> 
         <span class="next"><a href="xrsdk-meshing.html"></a></span> 
         <div class="tip">
           SDK Sitemap 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="footer-wrapper"> 
       <div class="footer clear"> 
        <div class="copy">
          © 2022 Unity Technologies. Tanggal Publikasi: 2022-04-04. 
        </div> 
        <div class="menu"> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div>  
 </body>
</html>
<!doctype html>
<html lang="en" class="no-js">
 <head> 
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> 
  <script type="text/javascript" src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" charset="UTF-8" data-domain-script="6e91be4c-3145-4ea2-aa64-89d716064836"></script> 
  <script type="text/javascript">
					function OptanonWrapper() { }
				</script> 
  <script>var offline=false;if(!offline){(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);  })(window,document,'script','dataLayer','GTM-K8K24X8');}</script> 
  <link href="https://fonts.googleapis.com/css?family=Roboto&amp;display=swap" rel="stylesheet"> 
  <meta charset="utf-8"> 
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <title>XR SDK Sitemap</title> 
  <meta property="og:image" content="https://unity3d.com/files/images/ogimg.jpg"> 
  <meta name="author" content="Unity Technologies"> 
  <link rel="shortcut icon" href="https://unity.com/themes/contrib/unity_base/images/favicons/favicon.ico"> 
  <link rel="icon" type="image/png" href="../StaticFilesManual/images/favicons/favicon.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../StaticFilesManual/images/favicons/apple-touch-icon-152x152.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../StaticFilesManual/images/favicons/apple-touch-icon-144x144.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="../StaticFilesManual/images/favicons/apple-touch-icon-120x120.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../StaticFilesManual/images/favicons/apple-touch-icon-114x114.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../StaticFilesManual/images/favicons/apple-touch-icon-72x72.png"> 
  <link rel="apple-touch-icon-precomposed" href="../StaticFilesManual/images/favicons/apple-touch-icon.png"> 
  <meta name="msapplication-TileColor" content="#222c37"> 
  <meta name="msapplication-TileImage" content="../StaticFilesManual/images/favicons/tileicon-144x144.png"> 
  <script type="text/javascript" src="https://docs.unity3d.com/StaticFilesConfig/UnityVersionsInfo.js"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/jquery.js?ts=20220404"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/core.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/toc.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/global_toc.js?ts=20220404"></script> 
  <link rel="stylesheet" type="text/css" href="../StaticFilesManual/css/core.css?ts=20220404"> 
  <link rel="stylesheet" href="../StaticFilesManual/css/prism.css"> 
  <script src="../StaticFilesManual/js/prism.js"></script> 
  <script src="/StaticFilesConfig/feedback/feedback.js"></script> 
  <script src="../StaticFilesManual/js/jquery.sidebar.min.js"></script> 
  <link rel="stylesheet" href="../StaticFilesManual/css/mobileoptimisation.css"> 
  <script src="../StaticFilesManual/js/mobileoptimisation.js"></script> 
 </head> 
 <body> 
  <noscript> 
   <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K8K24X8" height="0" width="0" style="display:none;visibility:hidden"></iframe> 
  </noscript> 
  <div id="DocsAnalyticsData" data-area="platforms" data-pagetype="manual"></div> 
  <div class="header-wrapper"> 
   <div id="header" class="header"> 
    <div class="content"> 
     <div class="spacer"> 
      <div class="menu"> 
       <div id="nav-open" for="nav-input"> 
        <span></span> 
       </div> 
       <div class="logo"></div> 
       <div class="search-form"> 
        <form action="30_search.html" method="get" class="apisearch"> 
         <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
         <input type="submit" class="submit"> 
        </form> 
       </div> 
       <ul> 
        <li><a href="../Manual/index.html" class="selected">Manual</a></li> 
        <li><a href="../ScriptReference/index.html">API documentation</a></li> 
       </ul> 
      </div> 
     </div> 
     <div class="more"> 
      <div class="filler"></div> 
      <ul> 
       <li></li> 
      </ul> 
     </div> 
    </div> 
   </div> 
   <div class="toolbar"> 
    <div class="content"> 
    </div> 
   </div> 
   <div class="mobileLogo"></div> 
  </div> 
  <div id="master-wrapper" class="master-wrapper clear"> 
   <div id="sidebar" class="sidebar"> 
    <div class="sidebar-wrap"> 
     <div class="content"> 
      <div class="sidebar-menu"> 
       <div class="toc" id="customScrollbar"> 
        <h2>Manual Unity</h2> 
        <div class="search-form sidebar-search-form"> 
         <form action="30_search.html" method="get" class="apisearch"> 
          <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
          <input type="submit" id="mobileSearchBtn" class="submit" value="Search"> 
         </form> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div id="content-wrap" class="content-wrap"> 
    <div class="content-block"> 
     <div class="content"> 
      <div class="section"> 
       <div class="breadcrumbs clear"> 
        <ul> 
         <li><a href="UnityManual.html">Unity User Manual 2022.1 (beta)</a></li> 
         <li><a href="XR.html">XR</a></li> 
         <li><a href="xr-sdk.html">SDK</a></li> 
         <li>Subsystems</li> 
         <li>SDK Sitemap</li> 
        </ul> 
       </div> 
       <div class="mb20"> 
        <div class="nextprev clear"> 
         <div class="icon tt left mr1" data-distance="-40|-30|top"> 
          <span class="prev"><a href="xrsdk-display.html"></a></span> 
          <div class="tip">
            XR SDK 
          </div> 
         </div> 
         <div class="icon tt right" data-distance="-40|-30|top"> 
          <span class="next"><a href="xrsdk-pre-init-interface.html"></a></span> 
          <div class="tip">
            Antarmuka PreInit SDK XR 
          </div> 
         </div> 
        </div> 
       </div> 
       <div id="_leavefeedback"></div> 
       <h1>SDK Sitemap</h1> 
       <!--BeginSwitchLink--> 
       <!--EndSwitchLink--> 
       <div class="clear"></div> 
       <p>Ekstrak subsistem Meshing <span class="tooltip"><strong>mesh</strong><span class="tooltiptext">Grafik utama primitif Unity. Mesh membuat sebagian besar dunia 3D Anda. Unity mendukung mesh poligon triangulat atau Quadrangulasi. Nurbs, Nurms, permukaan Subdiv harus dikonversi ke poligon. <a class="tooltipMoreInfoLink" href="comp-MeshGroup.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Mesh">Glossary</a></span></span></span> data dari Penyedia eksternal dan mengubahnya menjadi <a href="../ScriptReference/Mesh.html">Login Login</a>. Ini juga dapat menghasilkan <a href="../ScriptReference/MeshCollider.html">WordPress.org</a> opsional tanpa mengulangi kios benang utama.</p> 
       <p>Kasus penggunaan utama untuk subsistem Meshing adalah untuk jaring yang dihasilkan permukaan, umumnya dari algoritma <span class="tooltip"><strong>spatial mapping</strong><span class="tooltiptext">Proses pemetaan permukaan dunia nyata ke dunia virtual.<br><span class="tooltipGlossaryLink">Lihat di <a class="tooltipMoreInfoLink" href="Glossary.html#SpatialMapping">Glossary</a></span></span></span> seperti yang dihasilkan dari <span class="tooltip"><strong>camera</strong><span class="tooltiptext">Komponen yang menciptakan gambar sudut pandang tertentu di tempat kejadian Anda. Output ditarik ke layar atau ditangkap sebagai tekstur. <a href="CamerasOverview.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Camera">Glossary</a></span></span></span> kedalaman. Tidak ada batasan pada ukuran mesh, atau frekuensi pembaruan.</p> 
       <p>Generasi mesh terjadi secara serentak pada benang latar belakang, sehingga mengekstrak data dari penyedia eksternal tidak menghalangi benang utama ke, misalnya, bake mesh <span class="tooltip"><strong>collider</strong><span class="tooltiptext">Bentuk tak terlihat yang digunakan untuk menangani tabrakan fisik untuk objek. Seorang sari tidak perlu menjadi bentuk yang sama dengan jala objek - perkiraan kasar sering lebih efisien dan tidak dapat dibedakan dalam gameplay. <a class="tooltipMoreInfoLink" href="CollidersOverview.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Collider">Glossary</a></span></span></span>.</p> 
       <h2>Aliran kontrol</h2> 
       <p>Subsistem Meshing memiliki dua pertanyaan dasar:</p> 
       <ul> 
        <li>Dapatkan keadaan semua jaring yang dilacak (misalnya, Baru, Berubah, Tidak berubah, Dihapus).</li> 
        <li>Hasilkan mesh tertentu. Mesh diidentifikasi menggunakan pengidentifikasi <a href="../ScriptReference/XR.MeshId.html">MeshId</a>.</li> 
       </ul> 
       <h3>Getting MeshInfos</h3> 
       <p>C# pengguna bisa mendapatkan info mesh dari metode instance <code>XRMeshSubsystem</code>:</p> 
       <pre><code class="csharp">public bool TryGetMeshInfos(List&lt;MeshInfo&gt; meshInfosOut);
</code></pre> 
       <p>Peta ini langsung ke panggilan C ke <code>UnityXRMeshProvider::GetMeshInfos</code> dan biasanya disebut sekali per bingkai untuk mendapatkan daftar saat ini dari jaring yang dilacak.</p> 
       <p>Implementasi C berikut dapat menggunakan objek <code>allocator</code> yang disediakan untuk mengalokasikan array <code>UnityXRMeshInfo</code> yang harus diisi kemudian:</p> 
       <pre><code class="c">UnitySubsystemErrorCode(UNITY_INTERFACE_API * GetMeshInfos)(
        UnitySubsystemHandle handle, void* pluginData, UnityXRMeshInfoAllocator * allocator);
</code></pre> 
       <p>Memori yang dialokasikan dimiliki oleh Unity (biasanya menggunakan aokator stack, sehingga alokasi sangat cepat):</p> 
       <pre><code class="c">typedef struct UnityXRMeshInfo
{
    UnityXRMeshId meshId;
    bool updated;
    int priorityHint;
} UnityXRMeshInfo;
</code></pre> 
       <p>Jika tidak ada yang berubah karena panggilan terakhir ke <a href="../ScriptReference/XR.XRMeshSubsystem.TryGetMeshInfos.html">TryGetMeshInfos</a>, Anda dapat mengembalikan palsu untuk menghindari mengisi array setiap bingkai.</p> 
       <table> 
        <colgroup> 
         <col style="text-align:left;"> 
         <col style="text-align:left;"> 
        </colgroup> 
        <thead> 
         <tr> 
          <th style="text-align:left;"><strong>Field</strong></th> 
          <th style="text-align:left;"><strong>Description</strong></th> 
         </tr> 
        </thead> 
        <tbody> 
         <tr> 
          <td style="text-align:left;"><strong>meshId</strong></td> 
          <td style="text-align:left;">Pengidentifikasi unik 128-bit. Penyedia menghasilkan nilai-nilai ini, yang dapat menjadi pointer untuk data mesh, tetapi Anda perlu dapat menghasilkan mesh tertentu oleh IDnya.</td> 
         </tr> 
         <tr> 
          <td style="text-align:left;"><strong>updated</strong></td> 
          <td style="text-align:left;">Satu-satunya kebutuhan Unity adalah apakah mesh telah diperbarui sejak waktu terakhir itu dihasilkan. Menentukan apakah mesh ditambahkan atau dihapus dilakukan secara otomatis; melaporkan keberadaan jala yang Unity tidak tahu tentang di permukaan seperti Ditambahkan, sementara tidak melaporkan jala yang sebelumnya dilaporkan menandai mesh sebagai Hapus.</td> 
         </tr> 
         <tr> 
          <td style="text-align:left;"><strong>priorityHint</strong></td> 
          <td style="text-align:left;">C # menafsirkan nilai ini, tetapi Anda mungkin ingin, misalnya, menyediakan komponen C # yang memprioritaskan mesh mana yang menghasilkan berdasarkannya. Unity tidak menggunakan nilai ini.</td> 
         </tr> 
        </tbody> 
       </table> 
       <p>Di C#, <a href="../ScriptReference/XR.XRMeshSubsystem.TryGetMeshInfos.html">TryGetMeshInfos</a> menempati <code>List&lt;MeshInfo&gt;</code>, yang mencakup <a href="../ScriptReference/XR.MeshChangeState.html">keadaan jala</a>:</p> 
       <pre><code class="csharp">public enum MeshChangeState
{
    Added,
    Updated,
    Removed,
    Unchanged
}
</code></pre> 
       <p>Berdasarkan keadaan perubahan jala dan nilai petunjuk prioritas, komponen C# kemudian dapat memutuskan mesh mana (es) untuk menghasilkan berikutnya.</p> 
       <h3>Generasi Mesh</h3> 
       <p>Dari C #, Anda dapat menghasilkan asynchronous mesh tertentu menggunakan metode instance <a href="../ScriptReference/XR.XRMeshSubsystem.GenerateMeshAsync.html">XRMeshSubsystem</a>:</p> 
       <pre><code class="csharp">public extern void GenerateMeshAsync(
    MeshId meshId,
    Mesh mesh,
    MeshCollider meshCollider,
    MeshVertexAttributes attributes,
    Action&lt;MeshGenerationResult&gt; onMeshGenerationComplete);
</code></pre> 
       <p>Ini mempesona mesh untuk generasi. Anda dapat mempesona sebanyak yang Anda butuhkan, tetapi Anda mungkin ingin membatasi jumlah jala yang dihasilkan secara bersamaan dengan beberapa saat.</p> 
       <p>Unity selalu memanggil delegate <code>onMeshGenerationComplete</code> yang diberikan, bahkan jika kesalahan terjadi.</p> 
       <p>Mesh dihasilkan dalam dua fase, berikut model pengakuisisi dan rilis:</p> 
       <figure> 
        <img src="https://docs.unity3d.com/2022.1/Documentation/uploads/Main/acquire_release.png" alt=""> 
       </figure> 
       <pre><code class="c">UnitySubsystemErrorCode(UNITY_INTERFACE_API * AcquireMesh)(
    UnitySubsystemHandle handle,
    void* pluginData,
    const UnityXRMeshId * meshId,
    UnityXRMeshDataAllocator * allocator);
</code></pre> 
       <p> <code>AcquireMesh</code> disebut pada benang latar belakang, sehingga Anda dapat melakukan banyak pemrosesan dalam metode ini seperti yang Anda suka, termasuk pekerjaan intensif perhitungan seperti menghasilkan mesh itu sendiri. Fungsi ini dapat kembali segera atau rentang beberapa bingkai.</p> 
       <p>Jika Anda menyediakan struktur percepatan <code>MeshCollider</code>, Unity juga menghitung struktur percepatan MeshCollider (“Bake Fisika” dalam diagram di atas). Ini dapat memakan waktu untuk jala besar, sehingga juga terjadi pada benang pekerja.<code>GenerateMeshAsync</code>, Unity also computes the MeshCollider’s acceleration structure (“Bake Physics” in the above diagram). This can be time-consuming for large meshes, so it also occurs on the worker thread.</p> 
       <p>Akhirnya, ketika data siap, Unity menulisnya ke <code>UnityEngine.Mesh</code> dan / atau <code>UnityEngine.MeshCollider</code> pada benang utama. Setelah itu, panggilan Unity <code>ReleaseMesh</code>, juga pada benang utama:</p> 
       <pre><code class="c">UnitySubsystemErrorCode(UNITY_INTERFACE_API * ReleaseMesh)(
    UnitySubsystemHandle handle,
    void* pluginData,
    const UnityXRMeshId * meshId,
    const UnityXRMeshDescriptor * mesh,
    void* userData);
</code></pre> 
       <p>Karena<code>ReleaseMesh</code> disebut pada benang utama, harus kembali dengan cepat. Biasanya, ini digunakan untuk sumber daya gratis yang dialokasikan selama <code>AcquireMesh</code>.</p> 
       <h3>Manajemen memori</h3> 
       <p> <code>AcquireMesh</code> menawarkan dua cara menyediakan data mesh ke Unity: Unity-managed dan dikelola penyedia.</p> 
       <h4>Memori yang dikelola oleh Unity</h4> 
       <p>Untuk membiarkan Unity mengelola memori, gunakan:</p> 
       <pre><code class="c">UnityXRMeshDescriptor* (UNITY_INTERFACE_API * MeshDataAllocator_AllocateMesh)(
    UnityXRMeshDataAllocator * allocator,
    size_t vertexCount,
    size_t indexCount,
    UnityXRIndexFormat indexFormat,
    UnityXRMeshVertexAttributeFlags attributes,
    UnityXRMeshTopology topology);
</code></pre> 
       <p>Ini mengembalikan struct dengan pointer untuk penyangga berdasarkan persimpangan <code>attributes</code> ini dan atribut vertex yang diminta dari C#. Penyedia kemudian harus menyalin data yang sesuai untuk penyangga.</p> 
       <p>Ketika Anda menggunakan paradigm ini, Anda tidak harus membebaskan memori, karena Unity akan mendaur ulang memori setelah panggilan ke <code>ReleaseMesh</code>.</p> 
       <h4>Memori yang dikelola oleh penyedia</h4> 
       <p>Alih-alih membiarkan Unity mengelola memori, Anda dapat menunjukkannya pada data Anda sendiri. Data harus tetap berlaku sampai <code>ReleaseMesh</code> disebut.</p> 
       <p>Gunakan <code>MeshDataAllocator_SetMesh</code> untuk memberikan <code>UnityXRMeshDescriptor</code> Anda sendiri yang titik pointer non-null untuk data yang valid:</p> 
       <pre><code class="c">void(UNITY_INTERFACE_API * MeshDataAllocator_SetMesh)(
    UnityXRMeshDataAllocator * allocator, const UnityXRMeshDescriptor * meshDescriptor);
</code></pre> 
       <h4>User data</h4> 
       <p>Implementasi <code>AcquireMesh</code> Anda dapat memanggil:</p> 
       <pre><code class="c">void(UNITY_INTERFACE_API * MeshDataAllocator_SetUserData)(
    UnityXRMeshDataAllocator * allocator, void* userData);
</code></pre> 
       <p>Unity melewati pointer <code>userData</code> kembali ke implementasi <code>ReleaseMesh</code> Anda. Ini sangat berguna ketika Anda menggunakan memori yang dikelola oleh penyedia.</p> 
       <h2>Contoh komponen C#</h2> 
       <pre><code class="csharp">void Update()
{
    if (s_MeshSubsystem.TryGetMeshInfos(s_MeshInfos))
    {
        foreach (var meshInfo in s_MeshInfos)
        {
            switch (meshInfo.ChangeState)
            {
                case MeshChangeState.Added:
                case MeshChangeState.Updated:
                    AddToQueueIfNecessary(meshInfo);
                    break;

                case MeshChangeState.Removed:
                    RaiseMeshRemoved(meshInfo.MeshId);

                    // Remove from processing queue
                    m_MeshesNeedingGeneration.Remove(meshInfo.MeshId);

                    // Destroy the GameObject
                    GameObject meshGameObject;
                    if (meshIdToGameObjectMap.TryGetValue(meshInfo.MeshId, out meshGameObject))
                    {
                        Destroy(meshGameObject);
                        meshIdToGameObjectMap.Remove(meshInfo.MeshId);
                    }

                    break;

                default:
                    break;
            }
        }
    }

    // ...

    while (m_MeshesBeingGenerated.Count &lt; meshQueueSize &amp;&amp; m_MeshesNeedingGeneration.Count &gt; 0)
    {
        // Get the next mesh to generate. Could be based on the mesh's
        // priorityHint, whether it is new vs updated, etc.
        var meshId = GetNextMeshToGenerate();

        // Gather the necessary Unity objects for the generation request
        var meshGameObject = GetOrCreateGameObjectForMesh(meshId);
        var meshCollider = meshGameObject.GetComponent&lt;MeshCollider&gt;();
        var mesh = meshGameObject.GetComponent&lt;MeshFilter&gt;().mesh;
        var meshAttributes = shouldComputeNormals ? MeshVertexAttributes.Normals : MeshVertexAttributes.None;

        // Request generation
        s_MeshSubsystem.GenerateMeshAsync(meshId, mesh, meshCollider, meshAttributes, OnMeshGenerated);

        // Update internal state
        m_MeshesBeingGenerated.Add(meshId, m_MeshesNeedingGeneration[meshId]);
        m_MeshesNeedingGeneration.Remove(meshId);
    }
}

void OnMeshGenerated(MeshGenerationResult result)
{
    if (result.Status != MeshGenerationStatus.Success)
    {
        // Handle error, regenerate, etc.
    }

    m_MeshesBeingGenerated.Remove(result.MeshId);
}
</code></pre> 
       <!-- area:platforms --> 
       <div id="_content"></div> 
       <div class="nextprev clear"> 
        <div class="icon tt left mr1" data-distance="-40|-30|top"> 
         <span class="prev"><a href="xrsdk-display.html"></a></span> 
         <div class="tip">
           XR SDK 
         </div> 
        </div> 
        <div class="icon tt right" data-distance="-40|-30|top"> 
         <span class="next"><a href="xrsdk-pre-init-interface.html"></a></span> 
         <div class="tip">
           Antarmuka PreInit SDK XR 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="footer-wrapper"> 
       <div class="footer clear"> 
        <div class="copy">
          © 2022 Unity Technologies. Tanggal Publikasi: 2022-04-04. 
        </div> 
        <div class="menu"> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div>  
 </body>
</html>
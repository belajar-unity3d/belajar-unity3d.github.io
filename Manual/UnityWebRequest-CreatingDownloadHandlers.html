<!doctype html>
<html lang="en" class="no-js">
 <head> 
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> 
  <script type="text/javascript" src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" charset="UTF-8" data-domain-script="6e91be4c-3145-4ea2-aa64-89d716064836"></script> 
  <script type="text/javascript">
					function OptanonWrapper() { }
				</script> 
  <script>var offline=false;if(!offline){(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);  })(window,document,'script','dataLayer','GTM-K8K24X8');}</script> 
  <link href="https://fonts.googleapis.com/css?family=Roboto&amp;display=swap" rel="stylesheet"> 
  <meta charset="utf-8"> 
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <title>Unity - Manual: Membuat DownloadHandlers</title> 
  <meta property="og:image" content="https://unity3d.com/files/images/ogimg.jpg"> 
  <meta name="author" content="Unity Technologies"> 
  <link rel="shortcut icon" href="https://unity.com/themes/contrib/unity_base/images/favicons/favicon.ico"> 
  <link rel="icon" type="image/png" href="../StaticFilesManual/images/favicons/favicon.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../StaticFilesManual/images/favicons/apple-touch-icon-152x152.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../StaticFilesManual/images/favicons/apple-touch-icon-144x144.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="../StaticFilesManual/images/favicons/apple-touch-icon-120x120.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../StaticFilesManual/images/favicons/apple-touch-icon-114x114.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../StaticFilesManual/images/favicons/apple-touch-icon-72x72.png"> 
  <link rel="apple-touch-icon-precomposed" href="../StaticFilesManual/images/favicons/apple-touch-icon.png"> 
  <meta name="msapplication-TileColor" content="#222c37"> 
  <meta name="msapplication-TileImage" content="../StaticFilesManual/images/favicons/tileicon-144x144.png"> 
  <script type="text/javascript" src="https://docs.unity3d.com/StaticFilesConfig/UnityVersionsInfo.js"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/jquery.js?ts=20220404"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/core.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/toc.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/global_toc.js?ts=20220404"></script> 
  <link rel="stylesheet" type="text/css" href="../StaticFilesManual/css/core.css?ts=20220404"> 
  <link rel="stylesheet" href="../StaticFilesManual/css/prism.css"> 
  <script src="../StaticFilesManual/js/prism.js"></script> 
  <script src="/StaticFilesConfig/feedback/feedback.js"></script> 
  <script src="../StaticFilesManual/js/jquery.sidebar.min.js"></script> 
  <link rel="stylesheet" href="../StaticFilesManual/css/mobileoptimisation.css"> 
  <script src="../StaticFilesManual/js/mobileoptimisation.js"></script> 
 </head> 
 <body> 
  <noscript> 
   <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K8K24X8" height="0" width="0" style="display:none;visibility:hidden"></iframe> 
  </noscript> 
  <div id="DocsAnalyticsData" data-area="cloud" data-pagetype="manual"></div> 
  <div class="header-wrapper"> 
   <div id="header" class="header"> 
    <div class="content"> 
     <div class="spacer"> 
      <div class="menu"> 
       <div id="nav-open" for="nav-input"> 
        <span></span> 
       </div> 
       <div class="logo"></div> 
       <div class="search-form"> 
        <form action="30_search.html" method="get" class="apisearch"> 
         <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
         <input type="submit" class="submit"> 
        </form> 
       </div> 
       <ul> 
        <li><a href="../Manual/index.html" class="selected">Manual</a></li> 
        <li><a href="../ScriptReference/index.html">API documentation</a></li> 
       </ul> 
      </div> 
     </div> 
     <div class="more"> 
      <div class="filler"></div> 
      <ul> 
       <li></li> 
      </ul> 
     </div> 
    </div> 
   </div> 
   <div class="toolbar"> 
    <div class="content"> 
    </div> 
   </div> 
   <div class="mobileLogo"></div> 
  </div> 
  <div id="master-wrapper" class="master-wrapper clear"> 
   <div id="sidebar" class="sidebar"> 
    <div class="sidebar-wrap"> 
     <div class="content"> 
      <div class="sidebar-menu"> 
       <div class="toc" id="customScrollbar"> 
        <h2>Manual Unity</h2> 
        <div class="search-form sidebar-search-form"> 
         <form action="30_search.html" method="get" class="apisearch"> 
          <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
          <input type="submit" id="mobileSearchBtn" class="submit" value="Search"> 
         </form> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div id="content-wrap" class="content-wrap"> 
    <div class="content-block"> 
     <div class="content"> 
      <div class="section"> 
       <div class="breadcrumbs clear"> 
        <ul> 
         <li><a href="UnityManual.html"></a></li> 
         <li><a href="UNet.html">Multiplayer dan Jaringan</a></li> 
         <li><a href="UnityWebRequest.html">UnityWebRequest</a></li> 
         <li><a href="UnityWebRequest-LLAPI.html">Operasi lanjutan: Menggunakan LLAPI</a></li> 
         <li>Menciptakan DownloadHandlers</li> 
        </ul> 
       </div> 
       <div class="mb20"> 
        <div class="nextprev clear"> 
         <div class="icon tt left mr1" data-distance="-40|-30|top"> 
          <span class="prev"><a href="UnityWebRequest-CreatingUploadHandlers.html"></a></span> 
          <div class="tip">
            Membuat UploadHandlers 
          </div> 
         </div> 
         <div class="icon tt right" data-distance="-40|-30|top"> 
          <span class="next"><a href="Audio.html"></a></span> 
          <div class="tip">
            Audio 
          </div> 
         </div> 
        </div> 
       </div> 
       <div id="_leavefeedback"></div> 
       <h1>Menciptakan DownloadHandlers</h1> 
       <!--BeginSwitchLink--> 
       <!--EndSwitchLink--> 
       <div class="clear"></div> 
       <table> 
        <colgroup> 
         <col style="text-align:left;"> 
        </colgroup> 
        <thead> 
         <tr> 
          <th style="text-align:left;"></th> 
         </tr> 
        </thead> 
        <tbody> 
         <tr> 
          <td style="text-align:left;"> <strong>Important</strong>: UNet adalah solusi yang diuraikan, dan Solusi Multiplayer baru dan <span class="tooltip"><strong>Networking</strong><span class="tooltiptext">Sistem Unity yang memungkinkan game multiplayer di jaringan komputer. <a class="tooltipMoreInfoLink" href="UNetOverview.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Networking">Glossary</a></span></span></span> (Netcode untuk GameObjects) sedang berkembang. Untuk informasi lebih lanjut dan langkah selanjutnya melihat informasi di .</td> 
         </tr> 
        </tbody> 
       </table> 
       <p>Ada beberapa jenis <code>DownloadHandlers</code>:</p> 
       <ul> 
        <li> <code>DownloadHandlerBuffer</code> digunakan untuk penyimpanan data sederhana.</li> 
        <li> <code>DownloadHandlerFile</code> digunakan untuk mengunduh dan menyimpan file ke disk dengan jejak memori rendah.</li> 
        <li> <code>DownloadHandlerTexture</code> digunakan untuk mengunduh gambar.</li> 
        <li> <code>DownloadHandlerAssetBundle</code> digunakan untuk mengambil AssetBundles.</li> 
        <li> <code>DownloadHandlerAudioClip</code> digunakan untuk mengunduh file audio.</li> 
        <li> <code>DownloadHandlerMovieTexture</code> digunakan untuk mengunduh file video. Disarankan bahwa Anda menggunakan <a href="../ScriptReference/Video.VideoPlayer.html">VideoPlayer</a> untuk unduhan video dan pemutaran film karena MovieTexture dideprecated.</li> 
        <li> <code>DownloadHandlerScript</code> adalah kelas khusus. sendiri, itu tidak ada. Meme it Namun, kelas ini dapat diwarisi oleh kelas yang ditentukan pengguna. Kelas ini menerima callback dari sistem UnityWebRequest, yang kemudian dapat digunakan untuk melakukan penanganan data yang benar-benar kustom karena tiba dari jaringan.</li> 
       </ul> 
       <p>API mirip dengan antarmuka <code>DownloadHandlerTexture</code>.</p> 
       <p> <code>UnityWebRequest</code> memiliki properti <code>disposeDownloadHandlerOnDispose</code>, yang default untuk benar. Jika properti ini benar, ketika objek UnityWebRequest disposed, Dispose() juga akan disebut pada handler download terpasang rendering itu tidak berguna. Jika Anda menyimpan referensi untuk mengunduh handler lebih lama dari referensi ke UnityWebRequest, Anda harus mengatur disposeDownloadHandlerOnDispose ke false.</p> 
       <h2>DownloadHandlerBuffer</h2> 
       <p>Unduh Pegang adalah yang paling sederhana, dan menangani sebagian besar kasus penggunaan. Toko ini menerima data dalam penyangga kode asli. Ketika unduhan selesai, Anda dapat mengakses data penyangga baik sebagai array byte atau sebagai string teks.</p> 
       <h3>Example</h3> 
       <pre><code>using UnityEngine;
using UnityEngine.Networking;
using System.Collections;


public class MyBehaviour : MonoBehaviour {
    void Start() {
        StartCoroutine(GetText());
    }

    IEnumerator GetText() {
        UnityWebRequest www = new UnityWebRequest("https://www.my-server.com");
        www.downloadHandler = new DownloadHandlerBuffer();
        yield return www.SendWebRequest();

        if (www.result != UnityWebRequest.Result.Success) {
            Debug.Log(www.error);
        }
        else {
            // Show results as text
            Debug.Log(www.downloadHandler.text);

            // Or retrieve results as binary data
            byte[] results = www.downloadHandler.data;
        }
    }
}
</code></pre> 
       <h2>DownloadHandlerFile</h2> 
       <p>Ini adalah handler download khusus untuk file besar. Ini menulis didownload byte langsung ke file, sehingga penggunaan memori rendah terlepas dari ukuran file yang diunduh. Perbedaan dari penelusuran unduhan lain adalah bahwa Anda tidak bisa mendapatkan data dari yang ini, semua data disimpan ke file.</p> 
       <h2>Example</h2> 
       <pre><code>using System.Collections;
using System.IO;
using UnityEngine;
using UnityEngine.Networking;

public class FileDownloader : MonoBehaviour {

    void Start () {
        StartCoroutine(DownloadFile());
    }

    IEnumerator DownloadFile() {
        var uwr = new UnityWebRequest("https://unity3d.com/", UnityWebRequest.kHttpVerbGET);
        string path = Path.Combine(Application.persistentDataPath, "unity3d.html");
        uwr.downloadHandler = new DownloadHandlerFile(path);
        yield return uwr.SendWebRequest();
        if (uwr.result != UnityWebRequest.Result.Success)
            Debug.LogError(uwr.error);
        else
            Debug.Log("File successfully downloaded and saved to " + path);
    }
}
</code></pre> 
       <h2>DownloadHandlerTexture</h2> 
       <p>Alih-alih menggunakan <code>DownloadHandlerBuffer</code> untuk mengunduh file gambar dan kemudian membuat tekstur dari byte mentah menggunakan <code>Texture.LoadImage</code>, lebih efisien untuk menggunakan <code>DownloadHandlerTexture</code>.</p> 
       <p>Toko handler Download ini menerima data dalam <code>UnityEngine.Texture</code>. Pada penyelesaian download, decode JPEG dan PNG menjadi valid <code>UnityEngine.Texture objects</code>. Hanya satu salinan <code>UnityEngine.Texture</code> diciptakan per objek <code>DownloadHandlerTexture</code>. Ini mengurangi kinerja hit dari koleksi sampah. Pegang melakukan penyangga, dekompresi dan pembuatan tekstur dalam kode asli. Selain itu, penciptaan dekompresi dan tekstur dilakukan pada benang pekerja bukan benang utama, yang dapat meningkatkan waktu bingkai saat memuat tekstur besar.</p> 
       <p>Akhirnya, <code>DownloadHandlerTexture</code> hanya mengalokasikan memori yang berhasil ketika akhirnya membuat Tekstur itu sendiri, yang menghilangkan overhead pengumpulan sampah yang terkait dengan melakukan konversi byte-to-texture dalam skrip.</p> 
       <h3>Example</h3> 
       <p>Contoh berikut mengunduh file PNG dari internet, mengubahnya menjadi <span class="tooltip"><strong>Sprite</strong><span class="tooltiptext">Objek grafis 2D. Jika Anda digunakan untuk bekerja di 3D, Sprites pada dasarnya hanya tekstur standar tetapi ada teknik khusus untuk menggabungkan dan mengelola tekstur sprite untuk efisiensi dan kenyamanan selama perkembangan. <a class="tooltipMoreInfoLink" href="Sprites.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Sprite">Glossary</a></span></span></span>, dan menetapkannya ke <a href="script-Image.html">image</a>:</p> 
       <pre><code>using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Networking;
using System.Collections;

[RequireComponent(typeof(Image))]
public class ImageDownloader : MonoBehaviour {
    Image _img;

    void Start () {
        _img = GetComponent&lt;UnityEngine.UI.Image&gt;();
        Download("https://www.mysite.com/myimage.png");
    }

    public void Download(string url) {
        StartCoroutine(LoadFromWeb(url));
    }

    IEnumerator LoadFromWeb(string url)
    {
        UnityWebRequest wr = new UnityWebRequest(url);
        DownloadHandlerTexture texDl = new DownloadHandlerTexture(true);
        wr.downloadHandler = texDl;
        yield return wr.SendWebRequest();
        if (wr.result == UnityWebRequest.Result.Success) {
            Texture2D t = texDl.texture;
            Sprite s = Sprite.Create(t, new Rect(0, 0, t.width, t.height),
                Vector2.zero, 1f);
            _img.sprite = s;
        }
    }
}
</code></pre> 
       <h2>DownloadHandlerAssetBundle</h2> 
       <p>Keuntungan untuk ini khusus Download Handler adalah bahwa itu mampu streaming data ke sistem Aset Unity. Setelah sistem AssetBundle telah menerima data yang cukup, AssetBundle tersedia sebagai objek <code>UnityEngine.AssetBundle</code>. Hanya satu salinan objek <code>UnityEngine.AssetBundle</code> diciptakan. Ini sangat mengurangi alokasi memori jangka waktu serta dampak memori pemuatan Aset Anda. Hal ini juga memungkinkan Aset untuk sebagian digunakan sementara tidak sepenuhnya diunduh, sehingga Anda dapat streaming Aset.</p> 
       <p>Semua download dan dekompresi terjadi pada benang pekerja.</p> 
       <p>AsetBundles diunduh melalui objek <code>DownloadHandlerAssetBundle</code>, yang memiliki properti <code>assetBundle</code> khusus untuk mengambil AssetBundle.</p> 
       <p>Karena cara kerja sistem AssetBundle, semua AssetBundle harus memiliki alamat yang terkait dengan mereka. Secara umum, ini adalah URL nominal di mana mereka terletak (melakukan URL sebelum pengalihan). Dalam hampir semua kasus, Anda harus melewati URL yang sama seperti yang Anda lewatkan ke UnityWebRequest. Saat menggunakan <span class="tooltip"><strong>High Level API</strong><span class="tooltiptext">Sistem untuk membangun kemampuan multiplayer untuk permainan Unity. Ini dibangun di atas lapisan komunikasi real-time transportasi tingkat bawah, dan menangani banyak tugas umum yang diperlukan untuk permainan multiplayer. <a class="tooltipMoreInfoLink" href="UNetUsingHLAPI.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#HighLevelAPI">Glossary</a></span></span></span> (HLAPI), ini dilakukan untuk Anda.</p> 
       <h3>Example</h3> 
       <pre><code>using UnityEngine;
using UnityEngine.Networking;
using System.Collections;

public class MyBehaviour : MonoBehaviour {
    void Start() {
        StartCoroutine(GetAssetBundle());
    }

    IEnumerator GetAssetBundle() {
        UnityWebRequest www = new UnityWebRequest("https://www.my-server.com");
        DownloadHandlerAssetBundle handler = new DownloadHandlerAssetBundle(www.url, uint.MaxValue);
        www.downloadHandler = handler;
        yield return www.SendWebRequest();

        if (www.result != UnityWebRequest.Result.Success) {
            Debug.Log(www.error);
        }
        else {
            // Extracts AssetBundle
            AssetBundle bundle = handler.assetBundle;
        }
    }
}
</code></pre> 
       <h2>DownloadHandlerAudioClip</h2> 
       <p>Pegang unduhan ini dioptimalkan untuk mengunduh file audio. Alih-alih mengunduh byte mentah menggunakan <code>DownloadHandlerBuffer</code> dan kemudian membuat <code>AudioClip</code> dari mereka, Anda dapat menggunakan handler unduh ini untuk melakukannya dengan cara yang lebih nyaman.</p> 
       <h2>Example</h2> 
       <pre><code>using System.Collections;
using UnityEngine;
using UnityEngine.Networking;

public class AudioDownloader : MonoBehaviour {

    void Start () {
        StartCoroutine(GetAudioClip());
    }

    IEnumerator GetAudioClip() {
        using (var uwr = UnityWebRequestMultimedia.GetAudioClip("https://myserver.com/mysound.ogg", AudioType.OGGVORBIS)) {
            yield return uwr.SendWebRequest();
            if (uwr.result != UnityWebRequest.Result.Success) {
                Debug.LogError(uwr.error);
                yield break;
            }

            AudioClip clip = DownloadHandlerAudioClip.GetContent(uwr);
            // use audio clip
        }
    }
}
</code></pre> 
       <h2>DownloadHandlerScript</h2> 
       <p>Untuk pengguna yang memerlukan kendali penuh atas pemrosesan data yang diunduh, Unity menyediakan kelas <code>DownloadHandlerScript</code>.</p> 
       <p>Secara default, contoh kelas ini tidak ada. Namun, jika Anda mendapatkan kelas Anda sendiri dari <code>DownloadHandlerScript</code>, Anda dapat menimpa fungsi tertentu dan menggunakannya untuk menerima callback sebagai data tiba dari jaringan.</p> 
       <p>Sitemap Unduhan aktual terjadi pada benang pekerja, tetapi semua callback <strong>Note:</strong> beroperasi pada benang utama. Hindari melakukan operasi berat secara komputasi selama panggilan ini.<code>DownloadHandlerScript</code> callbacks operate on the main thread. Avoid performing computationally heavy operations during these callbacks.</p> 
       <h3>Fungsi untuk override</h3> 
       <h4>ReceiveContentLength()</h4> 
       <pre><code>protected void ReceiveContentLength(long contentLength);
</code></pre> 
       <p>Fungsi ini disebut ketika header Konten-Panjang diterima. Perhatikan bahwa callback ini dapat terjadi beberapa kali jika server Anda mengirim satu atau lebih tanggapan langsung selama pemrosesan UnityWebRequest Anda.</p> 
       <h4>OnContentComplete()</h4> 
       <pre><code>protected void OnContentComplete();
</code></pre> 
       <p>Fungsi ini disebut ketika UnityWebRequest telah sepenuhnya mengunduh semua data dari server, dan telah meneruskan semua data yang diterima ke callback ReceiveData.</p> 
       <h4>ReceiveData()</h4> 
       <pre><code>protected bool ReceiveData(byte[] data, long dataLength);
</code></pre> 
       <p>Fungsi ini disebut setelah data telah tiba dari server jarak jauh, dan disebut sekali per bingkai. argumen <code>data</code> mengandung byte mentah yang diterima dari server jarak jauh, dan <code>dataLength</code> menunjukkan panjang data baru dalam array data.</p> 
       <p>Ketika tidak menggunakan penyangga data pra-lokasi, sistem membuat array byte baru setiap kali panggilan callback ini, dan <code>dataLength</code> selalu sama dengan <code>data.Length</code>. Saat menggunakan penyangga data pra-dilokasi, penyangga data digunakan kembali, dan <code>dataLength</code> harus digunakan untuk menemukan jumlah byte yang diperbarui.</p> 
       <p>Fungsi ini membutuhkan nilai pengembalian sebesar <strong>true</strong> atau <strong>false</strong>. Jika Anda kembali <strong>false</strong>, sistem segera aborts UnityWebRequest. Jika Anda kembali <strong>true</strong>, pemrosesan terus normal.</p> 
       <h3>Hindari pengumpulan sampah overhead</h3> 
       <p>Banyak pengguna yang lebih maju Unity terkait dengan mengurangi lonjakan CPU karena pengumpulan sampah. Untuk pengguna ini, sistem UnityWebRequest memungkinkan pra-allokasi array byte kode yang dikelola, yang digunakan untuk memberikan data yang diunduh untuk mengunduh callback <code>ReceiveData</code>HandlerScript.</p> 
       <p>Menggunakan fungsi ini benar-benar menghilangkan alokasi memori kode yang dikelola saat menggunakan kelas DownloadHandlerScript-derived untuk menangkap data yang diunduh.</p> 
       <p>Untuk membuat <code>DownloadHandlerScript</code> beroperasi dengan penyangga yang dikelola sebelumnya, menyediakan array byte ke konstror <code>DownloadHandlerScript</code>.</p> 
       <p>Sitemap Ukuran array byte membatasi jumlah data yang dikirimkan ke callback ReceiveData setiap bingkai. Jika data Anda tiba perlahan-lahan, lebih banyak bingkai, Anda mungkin telah memberikan terlalu kecil dari array byte.<strong>Note:</strong> The size of the byte array limits the amount of data delivered to the ReceiveData callback each frame. If your data arrives slowly, over many frames, you may have provided too small of a byte array.</p> 
       <h4>Example</h4> 
       <pre><code>using UnityEngine;
using UnityEngine.Networking;

public class LoggingDownloadHandler : DownloadHandlerScript {

    // Standard scripted download handler - allocates memory on each ReceiveData callback

    public LoggingDownloadHandler(): base() {
    }

    // Pre-allocated scripted download handler
    // reuses the supplied byte array to deliver data.
    // Eliminates memory allocation.

    public LoggingDownloadHandler(byte[] buffer): base(buffer) {
    }

    // Required by DownloadHandler base class. Called when you address the 'bytes' property.

    protected override byte[] GetData() { return null; }

    // Called once per frame when data has been received from the network.

    protected override bool ReceiveData(byte[] data, int dataLength) {
        if(data == null || data.Length &lt; 1) {
            Debug.Log("LoggingDownloadHandler :: ReceiveData - received a null/empty buffer");
            return false;
        }

        Debug.Log(string.Format("LoggingDownloadHandler :: ReceiveData - received {0} bytes", dataLength));
        return true;
    }

    // Called when all data has been received from the server and delivered via ReceiveData.

    protected override void CompleteContent() {
        Debug.Log("LoggingDownloadHandler :: CompleteContent - DOWNLOAD COMPLETE!");
    }

    // Called when a Content-Length header is received from the server.

    protected override void ReceiveContentLengthHeader(ulong contentLength) {
        Debug.Log(string.Format("LoggingDownloadHandler :: ReceiveContentLength - length {0}", contentLength));
    }
}
</code></pre> 
       <!-- area:cloud --> 
       <div id="_content"></div> 
       <div class="nextprev clear"> 
        <div class="icon tt left mr1" data-distance="-40|-30|top"> 
         <span class="prev"><a href="UnityWebRequest-CreatingUploadHandlers.html"></a></span> 
         <div class="tip">
           Membuat UploadHandlers 
         </div> 
        </div> 
        <div class="icon tt right" data-distance="-40|-30|top"> 
         <span class="next"><a href="Audio.html"></a></span> 
         <div class="tip">
           Audio 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="footer-wrapper"> 
       <div class="footer clear"> 
        <div class="copy">
          Â© 2022 Unity Technologies. Tanggal Publikasi: 2022-04-04. 
        </div> 
        <div class="menu"> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div>  
 </body>
</html>
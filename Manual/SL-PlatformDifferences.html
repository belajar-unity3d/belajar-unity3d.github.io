<!doctype html>
<html lang="en" class="no-js">
 <head> 
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> 
  <script type="text/javascript" src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" charset="UTF-8" data-domain-script="6e91be4c-3145-4ea2-aa64-89d716064836"></script> 
  <script type="text/javascript">
					function OptanonWrapper() { }
				</script> 
  <script>var offline=false;if(!offline){(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);  })(window,document,'script','dataLayer','GTM-K8K24X8');}</script> 
  <link href="https://fonts.googleapis.com/css?family=Roboto&amp;display=swap" rel="stylesheet"> 
  <meta charset="utf-8"> 
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <title>Unity - Manual: Menulis naungan untuk API grafis yang berbeda</title> 
  <meta property="og:image" content="https://unity3d.com/files/images/ogimg.jpg"> 
  <meta name="author" content="Unity Technologies"> 
  <link rel="shortcut icon" href="https://unity.com/themes/contrib/unity_base/images/favicons/favicon.ico"> 
  <link rel="icon" type="image/png" href="../StaticFilesManual/images/favicons/favicon.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../StaticFilesManual/images/favicons/apple-touch-icon-152x152.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../StaticFilesManual/images/favicons/apple-touch-icon-144x144.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="../StaticFilesManual/images/favicons/apple-touch-icon-120x120.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../StaticFilesManual/images/favicons/apple-touch-icon-114x114.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../StaticFilesManual/images/favicons/apple-touch-icon-72x72.png"> 
  <link rel="apple-touch-icon-precomposed" href="../StaticFilesManual/images/favicons/apple-touch-icon.png"> 
  <meta name="msapplication-TileColor" content="#222c37"> 
  <meta name="msapplication-TileImage" content="../StaticFilesManual/images/favicons/tileicon-144x144.png"> 
  <script type="text/javascript" src="https://docs.unity3d.com/StaticFilesConfig/UnityVersionsInfo.js"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/jquery.js?ts=20220404"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/core.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/toc.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/global_toc.js?ts=20220404"></script> 
  <link rel="stylesheet" type="text/css" href="../StaticFilesManual/css/core.css?ts=20220404"> 
  <link rel="stylesheet" href="../StaticFilesManual/css/prism.css"> 
  <script src="../StaticFilesManual/js/prism.js"></script> 
  <script src="/StaticFilesConfig/feedback/feedback.js"></script> 
  <script src="../StaticFilesManual/js/jquery.sidebar.min.js"></script> 
  <link rel="stylesheet" href="../StaticFilesManual/css/mobileoptimisation.css"> 
  <script src="../StaticFilesManual/js/mobileoptimisation.js"></script> 
 </head> 
 <body> 
  <noscript> 
   <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K8K24X8" height="0" width="0" style="display:none;visibility:hidden"></iframe> 
  </noscript> 
  <div id="DocsAnalyticsData" data-area="none" data-pagetype="manual"></div> 
  <div class="header-wrapper"> 
   <div id="header" class="header"> 
    <div class="content"> 
     <div class="spacer"> 
      <div class="menu"> 
       <div id="nav-open" for="nav-input"> 
        <span></span> 
       </div> 
       <div class="logo"></div> 
       <div class="search-form"> 
        <form action="30_search.html" method="get" class="apisearch"> 
         <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
         <input type="submit" class="submit"> 
        </form> 
       </div> 
       <ul> 
        <li><a href="../Manual/index.html" class="selected">Manual</a></li> 
        <li><a href="../ScriptReference/index.html">API documentation</a></li> 
       </ul> 
      </div> 
     </div> 
     <div class="more"> 
      <div class="filler"></div> 
      <ul> 
       <li></li> 
      </ul> 
     </div> 
    </div> 
   </div> 
   <div class="toolbar"> 
    <div class="content"> 
    </div> 
   </div> 
   <div class="mobileLogo"></div> 
  </div> 
  <div id="master-wrapper" class="master-wrapper clear"> 
   <div id="sidebar" class="sidebar"> 
    <div class="sidebar-wrap"> 
     <div class="content"> 
      <div class="sidebar-menu"> 
       <div class="toc" id="customScrollbar"> 
        <h2>Manual Unity</h2> 
        <div class="search-form sidebar-search-form"> 
         <form action="30_search.html" method="get" class="apisearch"> 
          <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
          <input type="submit" id="mobileSearchBtn" class="submit" value="Search"> 
         </form> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div id="content-wrap" class="content-wrap"> 
    <div class="content-block"> 
     <div class="content"> 
      <div class="section"> 
       <div class="breadcrumbs clear"> 
        <ul> 
         <li><a href="UnityManual.html">Manual Pengguna Unity 2022.1 (beta)</a></li> 
         <li><a href="Graphics.html">Graphics</a></li> 
         <li><a href="Shaders.html">Shaders</a></li> 
         <li><a href="shader-writing.html">Menu Menu</a></li> 
         <li>Menulis naungan untuk API grafis yang berbeda</li> 
        </ul> 
       </div> 
       <div class="mb20"> 
        <div class="nextprev clear"> 
         <div class="icon tt left mr1" data-distance="-40|-30|top"> 
          <span class="prev"><a href="SL-SurfaceShaderTessellation.html"></a></span> 
          <div class="tip">
            Permukaan Shader dengan DX11 / OpenGL Inti Tesselasi 
          </div> 
         </div> 
         <div class="icon tt right" data-distance="-40|-30|top"> 
          <span class="next"><a href="shader-performance-debugging.html"></a></span> 
          <div class="tip">
            Memahami kinerja naungan 
          </div> 
         </div> 
        </div> 
       </div> 
       <div id="_leavefeedback"></div> 
       <h1>Menulis naungan untuk API grafis yang berbeda</h1> 
       <!--BeginSwitchLink--> 
       <!--EndSwitchLink--> 
       <div class="clear"></div> 
       <p>Dalam beberapa kasus, ada perbedaan dalam bagaimana rendering grafis berperilaku antara API grafis yang berbeda. Sebagian besar waktu Editor Unity menyembunyikan perbedaan, tetapi ada beberapa situasi di mana Editor tidak dapat melakukan ini untuk Anda. Situasi ini, dan tindakan yang perlu Anda ambil jika terjadi, tercantum di bawah ini.</p> 
       <h2>Render Tekstur koordinat</h2> 
       <p>Konvensi koordinat Tekstur vertikal berbeda antara dua jenis platform: Direct3D-like dan OpenGL-like.</p> 
       <ul> 
        <li> <strong>Direct3D-like</strong>: Koordinat adalah 0 di bagian atas dan meningkatkan ke bawah. Ini berlaku untuk Direct3D, Logam dan konsol.</li> 
        <li> <strong>OpenGL-like</strong>: Koordinat adalah 0 di bagian bawah dan meningkatkan ke atas. Ini berlaku untuk OpenGL dan OpenGL ES.</li> 
       </ul> 
       <p>Perbedaan ini cenderung tidak memiliki efek pada proyek Anda, selain ketika rendering menjadi <span class="tooltip"><a class="tooltipMoreInfoLink" href="class-RenderTexture.html">Render Tekstur</a><span class="tooltiptext">Jenis Tekstur khusus yang diciptakan dan diperbarui pada runtime. Untuk menggunakannya, pertama membuat Tekstur Render baru dan menunjuk salah satu Kamera Anda untuk membuatnya. Kemudian Anda dapat menggunakan Tekstur Render dalam Bahan seperti Tekstur biasa. <a href="class-RenderTexture.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#RenderTexture">Glossary</a></span></span></span>. Ketika rendering ke dalam Tekstur pada platform langsung3D-seperti, terbalik secara internal Unity rendering terbalik. Ini membuat konvensi cocok antara platform, dengan platform OpenGL-seperti konvensi standar.</p> 
       <p>Efek Gambar dan rendering di ruang UV adalah dua kasus umum di <span class="tooltip"><strong>Shaders</strong><span class="tooltiptext">Program yang berjalan di GPU. <a class="tooltipMoreInfoLink" href="Shaders.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Shader">Glossary</a></span></span></span> di mana Anda perlu mengambil tindakan untuk memastikan bahwa konvensi koordinat yang berbeda tidak membuat masalah dalam proyek Anda.</p> 
       <h3>Efek Gambar</h3> 
       <p>Ketika Anda menggunakan dan anti-aliasing, Tekstur sumber yang dihasilkan untuk Efek Gambar tidak dipotong sesuai dengan Konvensi platform TerbukaGL-seperti. Dalam hal ini, render Unity ke layar untuk mendapatkan anti-aliasing dan kemudian menyelesaikan rendering ke Tekstur Render untuk pemrosesan lebih lanjut dengan Efek Gambar.</p> 
       <p>Jika Efek Gambar Anda adalah salah satu sederhana yang memproses satu Tekstur Render pada waktu, <a class="tooltipMoreInfoLink" href="../ScriptReference/Graphics.Blit.html">Grafik Login</a> berurusan dengan koordinat yang tidak konsisten. Namun, jika Anda memproses lebih dari satu <a href="class-RenderTexture.html">Render Tekstur</a> bersama-sama di Anda, Tekstur Render cenderung keluar pada orientasi vertikal yang berbeda di platform yang mirip Direct3D dan ketika Anda menggunakan anti-aliasing. Untuk menstandardisasi koordinat, Anda perlu secara manual “flip” layar Tekstur terbalik dalam <span class="tooltip"><strong>Vertex Shader</strong><span class="tooltiptext">Program yang berjalan pada setiap simpul model 3D ketika model sedang diberikan. <a href="SL-ShaderPrograms.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#vertexshader">Glossary</a></span></span></span> Anda sehingga sesuai dengan standar koordinat OpenGL-like.</p> 
       <p>Sampel kode berikut menunjukkan cara melakukan ini:</p> 
       <pre><code>// Flip sampling of the Texture: 
// The main Texture
// texel size will have negative Y).

#if UNITY_UV_STARTS_AT_TOP
if (_MainTex_TexelSize.y &lt; 0)
        uv.y = 1-uv.y;
#endif

</code></pre> 
       <p>Situasi serupa terjadi dengan <a href="SL-GrabPass.html">GrabPass</a>. Tekstur render yang dihasilkan mungkin tidak benar-benar dimatikan di platform Direct3D-like (non-OpenGL-like). Jika sampel kode Shader AmbilPass Tekstur, gunakan fungsi <code>ComputeGrabScreenPos</code> dari file <a href="SL-BuiltinFunctions.html">UnityCG termasuk</a>.</p> 
       <h3>Pengirim di ruang UV</h3> 
       <p>Ketika rendering di ruang berkoordinasi Tekstur (UV) untuk efek atau alat khusus, Anda mungkin perlu menyesuaikan Anda Shaders sehingga rendering konsisten antara sistem Direct3D-like dan OpenGL-like. Anda juga mungkin perlu menyesuaikan rendering Anda antara rendering ke layar dan rendering ke Tekstur. Sesuaikan ini dengan membalikkan proyeksi Direct3D-seperti terbalik sehingga koordinatnya sesuai dengan koordinat proyeksi OpenGL-like.</p> 
       <p><a href="SL-UnityShaderVariables.html">variabel built-in</a> <code>ProjectionParams.x</code> mengandung nilai <code>+1</code> atau <code>–1</code>. <code>-1</code> menunjukkan proyeksi telah dibalik ke bawah untuk mencocokkan koordinat proyeksi TerbukaGL-seperti, sementara <code>+1</code> menunjukkan itu belum selesai. Anda dapat memeriksa nilai ini di Shaders Anda dan kemudian melakukan tindakan yang berbeda. Contoh di bawah ini memeriksa jika proyeksi telah dibalik dan, jika demikian, flips dan kemudian kembali koordinat UV untuk mencocokkan.</p> 
       <pre><code>float4 vert(float2 uv : TEXCOORD0) : SV_POSITION
{
    float4 pos;
    pos.xy = uv;
    // This example is rendering with upside-down flipped projection,
    // so flip the vertical UV coordinate too
    if (_ProjectionParams.x &lt; 0)
        pos.y = 1 - pos.y;
    pos.z = 0;
    pos.w = 1;
    return pos;
}
</code></pre> 
       <h2>Koordinat ruang klip</h2> 
       <p>Mirip dengan koordinat Tekstur, koordinat ruang klip (juga dikenal sebagai koordinat ruang pasca proyeksi) berbeda antara platform Direct3D-like dan OpenGL-like:</p> 
       <ul> 
        <li><p> <strong>Direct3D-like</strong>: Kedalaman ruang klip dari +1.0 di pesawat dekat ke 0,0 di pesawat jauh. Ini berlaku untuk Direct3D, Logam dan konsol.</p></li> 
        <li><p> <strong>OpenGL-like</strong>: Kedalaman ruang klip dari –1.0 di pesawat dekat ke +1.0 di pesawat jauh. Ini berlaku untuk OpenGL dan OpenGL ES.</p></li> 
       </ul> 
       <p>Di dalam kode Shader, Anda dapat menggunakan <code>UNITY_NEAR_CLIP_VALUE</code> <a href="SL-BuiltinMacros.html">makro built-in</a> untuk mendapatkan nilai pesawat dekat berdasarkan platform.</p> 
       <p>Di dalam kode skrip, gunakan <a href="../ScriptReference/GL.GetGPUProjectionMatrix.html">GL.GetGPUProjectionMatrix</a> untuk mengkonversi dari sistem koordinat Unity (yang mengikuti Konvensi OpenGL-like) ke koordinat langsung3D-seperti jika itu adalah apa yang diharapkan platform.</p> 
       <h2>Presisi komputasi Shader</h2> 
       <p>Untuk menghindari masalah presisi, pastikan Anda menguji Shaders Anda di platform target. GPU di perangkat seluler dan PC berbeda dalam bagaimana mereka memperlakukan jenis titik mengambang. PC GPU memperlakukan semua jenis titik mengambang (float, setengah dan tetap) sama - mereka melakukan semua perhitungan menggunakan presisi 32-bit penuh, sementara banyak perangkat seluler GPU tidak melakukan ini.</p> 
       <p>Lihat dokumentasi tentang <a href="SL-DataTypesAndPrecision.html">jenis data dan presisi</a> untuk rincian.</p> 
       <h2>deklarasi Const di Shaders</h2> 
       <p>Penggunaan <code>const</code> berbeda antara Microsoft HSL (lihat <a href="http://msdn.microsoft.com">msdn.microsoft.com</a>) dan GLSL OpenGL (lihat <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">Wikipedia</a>) Bahasa Shader.</p> 
       <ul> 
        <li><p>HLSL <code>const</code> Microsoft memiliki banyak makna yang sama seperti yang dilakukan di C# dan C++ dalam variabel yang dinyatakan read-only dalam lingkupnya tetapi dapat diinisialisasikan dengan cara apa pun.</p></li> 
        <li><p>OpenGL's GLSL <code>const</code> berarti bahwa variabel secara efektif adalah waktu kompilasi konstan, dan itu harus diinisialisasi dengan mengkompilasi batasan waktu (baik nilai literal atau perhitungan pada <code>const</code>s lainnya).</p></li> 
       </ul> 
       <p>Yang terbaik adalah mengikuti semantik GLSL OpenGL dan hanya menyatakan variabel sebagai <code>const</code> ketika benar-benar invariant. Hindari menginisialisasi variabel <code>const</code> dengan beberapa nilai <span class="tooltip"><strong>mutable</strong><span class="tooltiptext">Anda dapat mengubah isi paket mutable. Ini adalah kebalikan dari <strong>immutable</strong>. Hanya <strong>Local package</strong><strong>s</strong> dan <strong>Embedded package</strong><strong>s</strong> mutable.<br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Mutable">Glossary</a></span></span></span> lainnya (misalnya, sebagai variabel lokal dalam fungsi). Ini juga bekerja di HLSL Microsoft, sehingga menggunakan <code>const</code> dengan cara ini menghindari kesalahan membingungkan pada beberapa platform.</p> 
       <h2>Semantik yang digunakan oleh Shaders</h2> 
       <p>Untuk mendapatkan Shaders bekerja di semua platform, beberapa nilai Shader harus menggunakan semantik ini:</p> 
       <ul> 
        <li><p><strong>Vertex Shader output (clip space) position</strong>: <code>SV_POSITION</code>. Terkadang Shaders menggunakan semantik POSITION untuk mendapatkan Shaders bekerja di semua platform. Perhatikan bahwa ini tidak berfungsi pada Sony PS4 atau dengan tesselasi.</p></li> 
        <li><p><strong>Fragment Shader output color</strong>: <code>SV_Target</code>. Terkadang Shaders menggunakan <code>COLOR</code> atau <code>COLOR0</code> untuk mendapatkan Shaders bekerja pada semua platform. Perhatikan bahwa ini tidak berfungsi pada Sony PS4.</p></li> 
       </ul> 
       <p>Ketika rendering Meshes sebagai Poin, output <code>PSIZE</code> semantik dari simpul (misalnya, set ke 1). Beberapa platform, seperti OpenGL ES atau Metal, memperlakukan ukuran titik sebagai “tidak ditentukan” ketika tidak ditulis dari Shader.</p> 
       <p>Lihat dokumentasi tentang <a href="SL-ShaderSemantics.html">Shader semantics</a> untuk rincian lebih lanjut.</p> 
       <h2>Login Sitemap</h2> 
       <p>Login Platform D menggunakan <a href="shader-compilation.html">Login Catalog</a> Microsoft. compiler HLSL lebih ketat daripada kompiler lain tentang berbagai kesalahan Shader halus. Misalnya, tidak menerima nilai output fungsi yang tidak diinisialisasi dengan benar.</p> 
       <p>Situasi yang paling umum yang mungkin Anda jalankan menggunakan ini adalah:</p> 
       <ul> 
        <li>Pengubah vertex <span class="tooltip"><a class="tooltipMoreInfoLink" href="SL-SurfaceShaders.html">Permukaan Shader</a><span class="tooltiptext">Cara merampingkan naungan menulis untuk Pipeline Render Built-in. <a href="SL-SurfaceShaders.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#SurfaceShader">Glossary</a></span></span></span> yang memiliki parameter <code>out</code>. Memastikan output seperti ini:</li> 
       </ul> 
       <pre><code>  void vert (inout appdata_full v, out Input o) 
      {
        **UNITY_INITIALIZE_OUTPUT(Input,o);**
        // ...
      }
</code></pre> 
       <ul> 
        <li><p>Nilai awal yang sebagian. Misalnya, fungsi kembali <code>float4</code> tetapi kode hanya menetapkan nilai <code>.xyz</code> dari itu. Mengatur semua nilai atau perubahan ke <code>float3</code> jika Anda hanya membutuhkan tiga nilai.</p></li> 
        <li><p>Menggunakan <code>tex2D</code> di Vertex Shader. Ini tidak valid, karena turunan UV tidak ada di Shader simpul. Anda perlu sampel tingkat mip eksplisit bukan; misalnya, gunakan <code>tex2Dlod</code> (<code>tex, float4(uv,0,0)</code>). Anda juga perlu menambahkan <code>#pragma target 3.0</code> sebagai <code>tex2Dlod</code> adalah fitur Shader model 3.0.</p></li> 
       </ul> 
       <h2>DirectX 11 (DX11) HLSL sintaks di Shaders</h2> 
       <p>Beberapa bagian dari pipa kompilasi <a href="SL-SurfaceShaders.html">Permukaan Shader</a> tidak mengerti DirectX 11-specific HLSL (bahasa naungan Microsoft) sintaks.</p> 
       <p>Jika Anda menggunakan fitur HLSL seperti <code>StructuredBuffers</code>, <code>RWTextures</code> dan sintaksis non-DirectX 9 lainnya, bungkusnya di DirectX X11-only preprocessor macro seperti yang ditunjukkan dalam contoh di bawah ini.</p> 
       <pre><code>#ifdef SHADER_API_D3D11
// DirectX11-specific code, for example
StructuredBuffer&lt;float4&gt; myColors;
RWTexture2D&lt;float4&gt; myRandomWriteTexture;
#endif
</code></pre> 
       <p><a name="using-shader-framebuffer-fetch"></a></p> 
       <h2>Menggunakan janji shaderbuffer</h2> 
       <p>Beberapa GPU (yang paling terkenal dengan PowerVR di iOS) memungkinkan Anda untuk melakukan bentuk campuran yang dapat diprogram dengan menyediakan warna fragmen saat ini sebagai masukan ke Shader Fragment (lihat <code>EXT_shader_framebuffer_fetch</code> pada <a href="https://www.khronos.org/registry/gles/extensions/EXT/EXT_shader_framebuffer_fetch.txt">khronos.org</a>).</p> 
       <p>Hal ini dimungkinkan untuk menulis Shaders di Unity yang menggunakan fungsi pengambilan bingkaibuffer. Untuk melakukan ini, gunakan argumen warna <code>inout</code> ketika Anda menulis Shader Fragment dalam bahasa HLSL (bahasa pencukur Microsoft - lihat <a href="http://msdn.microsoft.com">msdn.microsoft.com</a>) atau Cg (bahasa yang dicukur oleh Nvidia - lihat <a href="http://www.nvidia.co.uk/">nvidia.co.uk</a>).</p> 
       <p>Contoh di bawah ini dalam Cg.</p> 
       <pre><code>CGPROGRAM
// only compile Shader for platforms that can potentially
// do it (currently gles,gles3,metal)
#pragma only_renderers framebufferfetch

void frag (v2f i, inout half4 ocol : SV_Target)
{
    // ocol can be read (current framebuffer color)
    // and written into (will change color to that one)
    // ...
}   
ENDCG
</code></pre> 
       <h2>Kedalaman (Z) arah di Shaders</h2> 
       <p>Arah kedalaman (Z) berbeda pada platform Shader yang berbeda.</p> 
       <p><strong>DirectX 11, DirectX 12, Metal: Reversed direction</strong></p> 
       <ul> 
        <li><p>Penyangga kedalaman (Z) adalah 1,0 di pesawat dekat, menurun menjadi 0,0 di pesawat jauh.</p></li> 
        <li><p>Rentang ruang klip adalah [dekat,0] (meskipun jarak dekat pesawat di dekat pesawat, menurun menjadi 0,0 di pesawat jauh).</p></li> 
       </ul> 
       <p><strong>Other platforms: Traditional direction</strong></p> 
       <ul> 
        <li><p>Nilai penyangga kedalaman (Z) adalah 0,0 di pesawat dekat dan 1.0 di pesawat jauh.</p></li> 
        <li>Ruang klip tergantung pada platform tertentu: 
         <ul> 
          <li>Di platform langsung3D-like, kisarannya adalah [0,far] (meaning 0,0 di pesawat dekat, meningkatkan jarak pesawat jauh di pesawat jauh).</li> 
          <li>Pada platform OpenGL-like, kisarannya adalah [kurang, jauh] (meaning minus jarak dekat pesawat di dekat pesawat, meningkatkan jarak pesawat jauh di pesawat jauh).</li> 
         </ul> </li> 
       </ul> 
       <p>Perhatikan bahwa kedalaman arah terbalik (Z), dikombinasikan dengan titik mengambang <span class="tooltip"><strong>depth buffer</strong><span class="tooltiptext">Sebuah toko memori yang memegang kedalaman nilai z setiap pixel dalam gambar, di mana nilai z adalah kedalaman untuk setiap piksel yang diberikan dari pesawat proyeksi. <a class="tooltipMoreInfoLink" href="class-RenderTexture.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#depthbuffer">Glossary</a></span></span></span>, secara signifikan meningkatkan presisi penyangga kedalaman terhadap arah tradisional. Keuntungan dari ini adalah kurang konflik untuk koordinat Z dan bayangan yang lebih baik, terutama ketika menggunakan pesawat dekat kecil dan pesawat jauh besar.</p> 
       <p>Jadi, ketika Anda menggunakan Shaders dari platform dengan kedalaman (Z) terbalik:</p> 
       <ul> 
        <li>UNITY_REVERSED_Z didefinisikan.</li> 
        <li>Sitemap Rentang tekstur tekstur tekstur adalah 1 (dekat) hingga 0 (jauh).<code>_CameraDepth</code> Texture texture range is 1 (near) to 0 (far).</li> 
        <li>Rentang ruang klip adalah dalam "dekat" (dekat) ke 0 (jauh).</li> 
       </ul> 
       <p>Namun, makro dan fungsi berikut secara otomatis melakukan perbedaan dalam arah (Z):</p> 
       <ul> 
        <li><code>Linear01Depth(float z)</code></li> 
        <li><code>LinearEyeDepth(float z)</code></li> 
        <li>UNITY_CALC_FOG_FACTOR(koord)</li> 
       </ul> 
       <h3>Mencapai Buffer kedalaman</h3> 
       <p>Jika Anda mengambil nilai buffer kedalaman (Z) secara manual, Anda mungkin ingin memeriksa arah penyangga. Berikut ini adalah contoh dari ini:</p> 
       <pre><code>float z = tex2D(_CameraDepthTexture, uv);
#if defined(UNITY_REVERSED_Z)
    z = 1.0f - z;
#endif
</code></pre> 
       <h3>Menggunakan ruang klip</h3> 
       <p>Jika Anda menggunakan ruang klip (Z) secara manual, Anda mungkin juga ingin perbedaan platform abstrak dengan menggunakan makro berikut:</p> 
       <p><code>float clipSpaceRange01 = UNITY_Z_0_FAR_FROM_CLIPSPACE(rawClipSpace);</code></p> 
       <p> <strong>Note</strong>: Makro ini tidak mengubah ruang klip di platform OpenGL atau OpenGL ES, sehingga kembali dalam "near"1 (near) sejauh ini (far) di platform ini.</p> 
       <h3>Projection matrices</h3> 
       <p> <a href="../ScriptReference/GL.GetGPUProjectionMatrix.html">GL.GetGPUProjectionMatrix()</a> mengembalikan matriks z-reverted jika Anda berada di platform di mana kedalaman (Z) terbalik. Namun, jika Anda bersaing dari matriks proyeksi secara manual (misalnya, untuk bayangan kustom atau rendering kedalaman), Anda perlu mengalihkan kedalaman (Z) arahkan diri Anda di mana itu berlaku melalui script.</p> 
       <p>Contoh ini di bawah ini:</p> 
       <pre><code>var shadowProjection = Matrix4x4.Ortho(...); //shadow camera projection matrix
var shadowViewMat = ...     //shadow camera view matrix
var shadowSpaceMatrix = ... //from clip to shadowMap texture space
    
//'m_shadowCamera.projectionMatrix' is implicitly reversed 
//when the engine calculates device projection matrix from the camera projection
m_shadowCamera.projectionMatrix = shadowProjection; 

//'shadowProjection' is manually flipped before being concatenated to 'm_shadowMatrix'
//because it is seen as any other matrix to a Shader.
if(SystemInfo.usesReversedZBuffer) 
{
    shadowProjection[2, 0] = -shadowProjection[2, 0];
    shadowProjection[2, 1] = -shadowProjection[2, 1];
    shadowProjection[2, 2] = -shadowProjection[2, 2];
    shadowProjection[2, 3] = -shadowProjection[2, 3];
}
    m_shadowMatrix = shadowSpaceMatrix * shadowProjection * shadowViewMat;
</code></pre> 
       <h3>Kedalaman (Z) bias</h3> 
       <p>Unity secara otomatis berurusan dengan bias kedalaman (Z) untuk memastikannya cocok dengan arah kedalaman Unity (Z). Namun, jika Anda menggunakan plugin rendering kode asli, Anda perlu mengabaikan kedalaman (kebalikan) (Z) bias dalam kode C++ Anda.</p> 
       <h4>Alat untuk memeriksa arah kedalaman (Z)</h4> 
       <ul> 
        <li>Gunakan <a href="../ScriptReference/SystemInfo-usesReversedZBuffer.html">SystemInfo.usesReversedZBuffer</a> untuk mengetahui apakah Anda berada di platform menggunakan kedalaman terbalik (Z).</li> 
       </ul> 
       <div id="_content"></div> 
       <div class="nextprev clear"> 
        <div class="icon tt left mr1" data-distance="-40|-30|top"> 
         <span class="prev"><a href="SL-SurfaceShaderTessellation.html"></a></span> 
         <div class="tip">
           Permukaan Shader dengan DX11 / OpenGL Inti Tesselasi 
         </div> 
        </div> 
        <div class="icon tt right" data-distance="-40|-30|top"> 
         <span class="next"><a href="shader-performance-debugging.html"></a></span> 
         <div class="tip">
           Memahami kinerja naungan 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="footer-wrapper"> 
       <div class="footer clear"> 
        <div class="copy">
          © 2022 Unity Technologies. Tanggal Publikasi: 2022-04-04. 
        </div> 
        <div class="menu"> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div>  
 </body>
</html>
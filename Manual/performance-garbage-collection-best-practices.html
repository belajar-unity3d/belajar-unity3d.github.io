<!doctype html>
<html lang="en" class="no-js">
 <head> 
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> 
  <script type="text/javascript" src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" charset="UTF-8" data-domain-script="6e91be4c-3145-4ea2-aa64-89d716064836"></script> 
  <script type="text/javascript">
					function OptanonWrapper() { }
				</script> 
  <script>var offline=false;if(!offline){(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);  })(window,document,'script','dataLayer','GTM-K8K24X8');}</script> 
  <link href="https://fonts.googleapis.com/css?family=Roboto&amp;display=swap" rel="stylesheet"> 
  <meta charset="utf-8"> 
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <title>Unity - Manual: Koleksi sampah praktik terbaik</title> 
  <meta property="og:image" content="https://unity3d.com/files/images/ogimg.jpg"> 
  <meta name="author" content="Unity Technologies"> 
  <link rel="shortcut icon" href="https://unity.com/themes/contrib/unity_base/images/favicons/favicon.ico"> 
  <link rel="icon" type="image/png" href="../StaticFilesManual/images/favicons/favicon.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../StaticFilesManual/images/favicons/apple-touch-icon-152x152.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../StaticFilesManual/images/favicons/apple-touch-icon-144x144.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="../StaticFilesManual/images/favicons/apple-touch-icon-120x120.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../StaticFilesManual/images/favicons/apple-touch-icon-114x114.png"> 
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../StaticFilesManual/images/favicons/apple-touch-icon-72x72.png"> 
  <link rel="apple-touch-icon-precomposed" href="../StaticFilesManual/images/favicons/apple-touch-icon.png"> 
  <meta name="msapplication-TileColor" content="#222c37"> 
  <meta name="msapplication-TileImage" content="../StaticFilesManual/images/favicons/tileicon-144x144.png"> 
  <script type="text/javascript" src="https://docs.unity3d.com/StaticFilesConfig/UnityVersionsInfo.js"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/jquery.js?ts=20220404"></script> 
  <script type="text/javascript" src="../StaticFilesManual/js/core.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/toc.js?ts=20220404"></script> 
  <script type="text/javascript" src="docdata/global_toc.js?ts=20220404"></script> 
  <link rel="stylesheet" type="text/css" href="../StaticFilesManual/css/core.css?ts=20220404"> 
  <link rel="stylesheet" href="../StaticFilesManual/css/prism.css"> 
  <script src="../StaticFilesManual/js/prism.js"></script> 
  <script src="/StaticFilesConfig/feedback/feedback.js"></script> 
  <script src="../StaticFilesManual/js/jquery.sidebar.min.js"></script> 
  <link rel="stylesheet" href="../StaticFilesManual/css/mobileoptimisation.css"> 
  <script src="../StaticFilesManual/js/mobileoptimisation.js"></script> 
 </head> 
 <body> 
  <noscript> 
   <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K8K24X8" height="0" width="0" style="display:none;visibility:hidden"></iframe> 
  </noscript> 
  <div id="DocsAnalyticsData" data-area="none" data-pagetype="manual"></div> 
  <div class="header-wrapper"> 
   <div id="header" class="header"> 
    <div class="content"> 
     <div class="spacer"> 
      <div class="menu"> 
       <div id="nav-open" for="nav-input"> 
        <span></span> 
       </div> 
       <div class="logo"></div> 
       <div class="search-form"> 
        <form action="30_search.html" method="get" class="apisearch"> 
         <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
         <input type="submit" class="submit"> 
        </form> 
       </div> 
       <ul> 
        <li><a href="../Manual/index.html" class="selected">Manual</a></li> 
        <li><a href="../ScriptReference/index.html">API documentation</a></li> 
       </ul> 
      </div> 
     </div> 
     <div class="more"> 
      <div class="filler"></div> 
      <ul> 
       <li></li> 
      </ul> 
     </div> 
    </div> 
   </div> 
   <div class="toolbar"> 
    <div class="content"> 
    </div> 
   </div> 
   <div class="mobileLogo"></div> 
  </div> 
  <div id="master-wrapper" class="master-wrapper clear"> 
   <div id="sidebar" class="sidebar"> 
    <div class="sidebar-wrap"> 
     <div class="content"> 
      <div class="sidebar-menu"> 
       <div class="toc" id="customScrollbar"> 
        <h2>Manual Unity</h2> 
        <div class="search-form sidebar-search-form"> 
         <form action="30_search.html" method="get" class="apisearch"> 
          <input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"> 
          <input type="submit" id="mobileSearchBtn" class="submit" value="Search"> 
         </form> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div id="content-wrap" class="content-wrap"> 
    <div class="content-block"> 
     <div class="content"> 
      <div class="section"> 
       <div class="breadcrumbs clear"> 
        <ul> 
         <li><a href="UnityManual.html">Manual Pengguna Unity 2022.1 (beta)</a></li> 
         <li><a href="UnityOverview.html">Bekerja di Unity</a></li> 
         <li><a href="analysis.html">Analysis</a></li> 
         <li><a href="performance-memory-overview.html">Memori dalam Unity</a></li> 
         <li><a href="performance-garbage-collector.html">Gambaran keseluruhan kolektor sampah</a></li> 
         <li>Pengumpulan sampah praktik terbaik</li> 
        </ul> 
       </div> 
       <div class="mb20"> 
        <div class="nextprev clear"> 
         <div class="icon tt left mr1" data-distance="-40|-30|top"> 
          <span class="prev"><a href="performance-disabling-garbage-collection.html"></a></span> 
          <div class="tip">
            Mengaktifkan koleksi sampah 
          </div> 
         </div> 
         <div class="icon tt right" data-distance="-40|-30|top"> 
          <span class="next"><a href="Profiler.html"></a></span> 
          <div class="tip">
            Profiler 
          </div> 
         </div> 
        </div> 
       </div> 
       <div id="_leavefeedback"></div> 
       <h1>Pengumpulan sampah praktik terbaik</h1> 
       <!--BeginSwitchLink--> 
       <!--EndSwitchLink--> 
       <div class="clear"></div> 
       <p> <a href="performance-garbage-collector.html">Photogallery</a> otomatis, tetapi proses membutuhkan waktu CPU yang signifikan.</p> 
       <p>Manajemen memori otomatis C# mengurangi risiko kebocoran memori dan kesalahan pemrograman lainnya, dibandingkan dengan bahasa pemrograman lainnya seperti C++, di mana Anda harus melacak secara manual dan membebaskan semua memori yang Anda temukan.</p> 
       <p>Manajemen memori otomatis memungkinkan Anda untuk menulis kode dengan cepat dan mudah, dan dengan beberapa kesalahan. Namun, kenyamanan ini mungkin memiliki implikasi kinerja. Untuk mengoptimalkan kode Anda untuk kinerja, Anda harus menghindari situasi di mana aplikasi Anda memicu <a href="performance-garbage-collector.html">kolektor sampah</a> banyak. Bagian ini menguraikan beberapa masalah umum dan alur kerja yang mempengaruhi ketika aplikasi Anda memicu kolektor sampah.</p> 
       <ul> 
        <li><a href="#tempalloc">Alokasi sementara</a></li> 
        <li><a href="#reusablepools">Kolam objek yang dapat digunakan kembali</a></li> 
        <li><a href="#repeatedstring">WordPress.org</a></li> 
        <li><a href="#methodarray">Metode mengembalikan nilai array</a></li> 
        <li><a href="#collectionreuse">Koleksi dan penggunaan array</a></li> 
        <li><a href="#closures">Penutupan dan metode anonim</a></li> 
        <li><a href="#boxing">Boxing</a></li> 
        <li><a href="#arrayapis">API Unity</a></li> 
        <li><a href="#emptyarray">Reuse array kosong</a></li> 
       </ul> 
       <p><a name="tempalloc"></a></p> 
       <h2>Alokasi sementara</h2> 
       <p>Ini umum untuk aplikasi untuk mengalokasikan data sementara ke <a href="performance-managed-memory.html#managed-heap">managed heap</a> dalam setiap bingkai; namun, ini dapat mempengaruhi kinerja aplikasi. Contoh:</p> 
       <ul> 
        <li>Jika program mengalokasikan satu kilobyte (1KB) memori sementara setiap bingkai, dan berjalan pada 60 <span class="tooltip"><strong>frames per second</strong><span class="tooltiptext">Frekuensi di mana bingkai berturut-turut ditampilkan dalam permainan berjalan. <a class="tooltipMoreInfoLink" href="RenderingStatistics.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#framespersecond">Glossary</a></span></span></span>, maka harus mengalokasikan 60 kilobyte memori sementara per detik. Selama satu menit, ini menambah hingga 3.6 megabyte memori yang tersedia untuk kolektor sampah.</li> 
        <li>Mencapai kolektor sampah sekali per detik memiliki efek negatif pada kinerja. Jika kolektor sampah hanya berjalan sekali per menit, itu harus membersihkan 3,6 megabyte tersebar di ribuan alokasi individu, yang mungkin mengakibatkan waktu pengumpulan sampah yang signifikan.</li> 
        <li>Memuat operasi memiliki dampak pada kinerja. Jika aplikasi Anda menghasilkan banyak benda sementara selama operasi beban aset berat, dan referensi Unity objek-objek tersebut sampai operasi selesai, maka kolektor sampah tidak dapat melepaskan benda-benda sementara tersebut. Ini berarti bahwa landak yang berhasil perlu berkembang, meskipun Unity melepaskan banyak objek yang mengandung waktu singkat kemudian.</li> 
       </ul> 
       <p>Untuk mendapatkan sekitar ini, Anda harus mencoba untuk mengurangi jumlah alokasi heap yang sering dikelola mungkin: ideal untuk 0 byte per bingkai, atau dekat dengan nol karena Anda bisa mendapatkan.</p> 
       <p><a name="reusablepools"></a></p> 
       <h2>Kolam objek yang dapat digunakan kembali</h2> 
       <p>Ada banyak kasus di mana Anda dapat mengurangi jumlah kali aplikasi Anda menciptakan dan menghancurkan objek, untuk menghindari menghasilkan sampah. Ada jenis objek tertentu dalam permainan, seperti proyektil, yang mungkin muncul dan lagi meskipun hanya sejumlah kecil yang pernah bermain sekaligus. Dalam kasus seperti ini, Anda dapat menggunakan kembali objek, daripada menghancurkan yang lama dan menggantinya dengan yang baru.</p> 
       <p>Sebagai contoh, tidak optimal untuk mengulang objek proyektil baru dari <span class="tooltip"><strong>Prefab</strong><span class="tooltiptext">Jenis aset yang memungkinkan Anda untuk menyimpan GameObject lengkap dengan komponen dan properti. Prefab bertindak sebagai template dari mana Anda dapat membuat instance objek baru di tempat kejadian. <a class="tooltipMoreInfoLink" href="Prefabs.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a class="tooltipMoreInfoLink" href="Glossary.html#Prefab">Glossary</a></span></span></span> setiap kali satu dipecat. Alih-alih, Anda dapat menghitung jumlah proyektil maksimum yang pernah ada secara bersamaan selama gameplay, dan meluruskan array objek dengan ukuran yang benar ketika permainan pertama memasuki gameplay <span class="tooltip"><strong>scene</strong><span class="tooltiptext">Adegan berisi lingkungan dan menu permainan Anda. Pikirkan setiap file Adegan unik sebagai tingkat yang unik. Di setiap Adegan, Anda menempatkan lingkungan, hambatan, dan dekorasi, pada dasarnya merancang dan membangun permainan Anda dalam potongan-potongan. <a href="CreatingScenes.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Scene">Glossary</a></span></span></span>. Untuk melakukan ini:</p> 
       <ul> 
        <li>Mulai dengan semua set proyektil <span class="tooltip"><strong>GameObjects</strong><span class="tooltiptext">Objek mendasar dalam adegan Unity, yang dapat mewakili karakter, props, pemandangan, kamera, waypoints, dan banyak lagi. Fungsi GameObject didefinisikan oleh Komponen yang melekat padanya. <a class="tooltipMoreInfoLink" href="class-GameObject.html">More info</a><br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#GameObject">Glossary</a></span></span></span> untuk tidak aktif.</li> 
        <li>Ketika proyektil dipecat, cari melalui array untuk menemukan proyektil inaktif pertama di array, pindahkan ke posisi yang diperlukan dan atur GameObject untuk aktif.</li> 
        <li>Ketika proyektil hancur, atur GameObject untuk tidak aktif lagi.</li> 
       </ul> 
       <p>Anda dapat menggunakan kelas <a href="../ScriptReference/Pool.ObjectPool_1.html">ObjectPool</a>, yang memberikan implementasi teknik kolam objek yang dapat digunakan kembali ini.</p> 
       <p>Kode di bawah ini menunjukkan implementasi sederhana dari kolam objek berbasis stack. Anda mungkin merasa berguna untuk merujuk apakah Anda menggunakan versi Unity yang lebih tua yang tidak mengandung API ObjectPool, atau jika Anda ingin melihat contoh bagaimana kolam objek kustom mungkin diterapkan.</p> 
       <pre><code class="lang-csharp">using System.Collections.Generic;
using UnityEngine;

public class ExampleObjectPool : MonoBehaviour {

   public GameObject PrefabToPool;
   public int MaxPoolSize = 10;
  
   private Stack&lt;GameObject&gt; inactiveObjects = new Stack&lt;GameObject&gt;();
  
   void Start() {
       if (PrefabToPool != null) {
           for (int i = 0; i &lt; MaxPoolSize; ++i) {
               var newObj = Instantiate(PrefabToPool);
               newObj.SetActive(false);
               inactiveObjects.Push(newObj);
           }
       }
   }

   public GameObject GetObjectFromPool() {
       while (inactiveObjects.Count &gt; 0) {
           var obj = inactiveObjects.Pop();
          
           if (obj != null) {
               obj.SetActive(true);
               return obj;
           }
           else {
               Debug.LogWarning("Found a null object in the pool. Has some code outside the pool destroyed it?");
           }
       }
      
       Debug.LogError("All pooled objects are already in use or have been destroyed");
       return null;
   }
  
   public void ReturnObjectToPool(GameObject objectToDeactivate) {
       if (objectToDeactivate != null) {
           objectToDeactivate.SetActive(false);
           inactiveObjects.Push(objectToDeactivate);
       }
   }
}
</code></pre> 
       <p><a name="repeatedstring"></a></p> 
       <h2>WordPress.org</h2> 
       <p>String di C# adalah tipe referensi <span class="tooltip"><strong>immutable</strong><span class="tooltiptext">Anda tidak dapat mengubah isi paket immutable (read-only). Ini adalah kebalikan dari <strong>mutable</strong>. Kebanyakan paket tidak dapat diakses, termasuk paket yang diunduh dari registry paket atau melalui URL Git.<br><span class="tooltipGlossaryLink">Lihat di <a href="Glossary.html#Immutable">Glossary</a></span></span></span>. Jenis referensi berarti bahwa Unity mengalokasikan mereka di tumpukan yang berhasil dan tunduk pada pengumpulan sampah. Cara yang tidak diinginkan yang pernah dibuat string, tidak dapat diubah; setiap upaya untuk memodifikasi hasil string dalam string yang sama sekali baru. Untuk alasan ini, Anda harus menghindari membuat string sementara di mana pun mungkin.</p> 
       <p>Pertimbangkan kode contoh berikut, yang menggabungkan array string menjadi string tunggal. Setiap kali string baru ditambahkan di dalam lingkaran, konten sebelumnya dari variabel hasil menjadi redundan, dan kode mengalokasikan seluruh string baru.</p> 
       <pre><code class="lang-csharp">// Bad C# script example: repeated string concatenations create lots of
// temporary strings.
using UnityEngine;

public class ExampleScript : MonoBehaviour {
    string ConcatExample(string[] stringArray) {
        string result = "";

        for (int i = 0; i &lt; stringArray.Length; i++) {
            result += stringArray[i];
        }

        return result;
    }

}
</code></pre> 
       <p>Jika stringArray input mengandung <code>{ “A”, “B”, “C”, “D”, “E” }</code>, metode ini menghasilkan penyimpanan pada heap untuk string berikut:</p> 
       <ul> 
        <li><code>“A”</code></li> 
        <li><code>“AB”</code></li> 
        <li><code>“ABC”</code></li> 
        <li><code>“ABCD”</code></li> 
        <li><code>“ABCDE”</code></li> 
       </ul> 
       <p>Dalam contoh ini, Anda hanya perlu string akhir, dan yang lain adalah alokasi redundan. Semakin banyak item yang ada di array input, semakin banyak string metode ini menghasilkan, setiap lebih lama dari yang terakhir.</p> 
       <p>Jika Anda perlu untuk membuat banyak string bersama-sama maka Anda harus menggunakan kelas <a href="http://msdn.microsoft.com/en-gb/library/system.text.stringbuilder.aspx"><code>System.Text.StringBuilder</code></a> mono perpustakaan. Versi yang lebih baik dari script di atas terlihat seperti ini:</p> 
       <pre><code class="lang-csharp">// Good C# script example: StringBuilder avoids creating temporary strings,
// and only allocates heap memory for the final result string.
using UnityEngine;
using System.Text;

public class ExampleScript : MonoBehaviour {
    private StringBuilder _sb = new StringBuilder(16);

    string ConcatExample(string[] stringArray) {
        _sb.Clear();

        for (int i = 0; i &lt; stringArray.Length; i++) {
            _sb.Append(stringArray[i]);
        }

        return _sb.ToString();
    }
}
</code></pre> 
       <p>Kondensasi berulang tidak mengurangi kinerja terlalu banyak kecuali itu disebut sering, seperti pada setiap pembaruan bingkai. Contoh berikut mengalokasikan string baru setiap kali Memperbarui disebut, dan menghasilkan aliran objek yang terus menerus yang kolektor sampah harus ditangani:</p> 
       <pre><code class="lang-csharp">// Bad C# script example: Converting the score value to a string every frame
// and concatenating it with “Score: “ generates strings every frame.
using UnityEngine;
using UnityEngine.UI;

public class ExampleScript : MonoBehaviour {
    public Text scoreBoard;
    public int score;
    
    void Update() {
        string scoreText = "Score: " + score.ToString();
        scoreBoard.text = scoreText;
    }
}
</code></pre> 
       <p>Untuk mencegah persyaratan berkelanjutan ini untuk pengumpulan sampah, Anda dapat mengkonfigurasi kode sehingga teks hanya memperbarui ketika skor berubah:</p> 
       <pre><code class="lang-csharp">// Better C# script example: the score conversion is only performed when the
// score has changed
using UnityEngine;
using UnityEngine.UI;

public class ExampleScript : MonoBehaviour {
    public Text scoreBoard;
    public string scoreText;
    public int score;
    public int oldScore;
    
    void Update() {
        if (score != oldScore) {
            scoreText = "Score: " + score.ToString();
            scoreBoard.text = scoreText;
            oldScore = score;
        }
    }
}
</code></pre> 
       <p>Untuk meningkatkan lebih lanjut ini, Anda dapat menyimpan judul skor (bagian yang mengatakan <code>“Score: ”</code>) dan tampilan skor dalam dua objek <code>UI.Text</code> yang berbeda, yang berarti bahwa tidak perlu untuk komputasi string. Kode harus tetap mengubah nilai skor menjadi string, tetapi ini adalah peningkatan versi sebelumnya:</p> 
       <pre><code class="lang-csharp">// Best C# script example: the score conversion is only performed when the
// score has changed, and the string concatenation has been removed
using UnityEngine;
using UnityEngine.UI;

public class ExampleScript : MonoBehaviour {
   public Text scoreBoardTitle;
   public Text scoreBoardDisplay;
   public string scoreText;
   public int score;
   public int oldScore;

   void Start() {
       scoreBoardTitle.text = "Score: ";
   }

   void Update() {
       if (score != oldScore) {
           scoreText = score.ToString();
           scoreBoardDisplay.text = scoreText;
           oldScore = score;
       }
   }
}
</code></pre> 
       <p><a name="methodarray"></a></p> 
       <h2>Metode mengembalikan nilai array</h2> 
       <p>Kadang-kadang mungkin nyaman untuk menulis metode yang menciptakan array baru, mengisi array dengan nilai dan kemudian mengembalikannya. Namun, jika metode ini disebut berulang kali, maka memori baru dialokasikan setiap kali.</p> 
       <p>Kode contoh berikut menunjukkan contoh metode yang membuat array setiap kali disebut:</p> 
       <pre><code class="lang-csharp">// Bad C# script example: Every time the RandomList method is called it
// allocates a new array
using UnityEngine;
using System.Collections;

public class ExampleScript : MonoBehaviour {
    float[] RandomList(int numElements) {
        var result = new float[numElements];
        
        for (int i = 0; i &lt; numElements; i++) {
            result[i] = Random.value;
        }
        
        return result;
    }
}
</code></pre> 
       <p>Satu cara Anda dapat menghindari mengalokasikan memori setiap kali adalah untuk menggunakan fakta bahwa array adalah jenis referensi. Anda dapat mengubah array yang dilewati menjadi metode sebagai parameter, dan hasilnya tetap setelah metode kembali. Untuk melakukan ini, Anda dapat mengkonfigurasi kode contoh sebagai berikut:</p> 
       <pre><code class="lang-csharp">// Good C# script example: This version of method is passed an array to fill
// with random values. The array can be cached and re-used to avoid repeated
// temporary allocations
using UnityEngine;
using System.Collections;

public class ExampleScript : MonoBehaviour {
    void RandomList(float[] arrayToFill) {
        for (int i = 0; i &lt; arrayToFill.Length; i++) {
            arrayToFill[i] = Random.value;
        }
    }
}
</code></pre> 
       <p>Kode ini menggantikan konten yang ada dari array dengan nilai-nilai baru. Aliran kerja ini membutuhkan kode panggilan untuk melakukan alokasi awal array, tetapi fungsi tidak menghasilkan sampah baru ketika disebut. array kemudian dapat digunakan kembali dan diisi ulang dengan nomor acak metode ini disebut tanpa alokasi baru di landak yang dikelola.</p> 
       <p><a name="collectionreuse"></a></p> 
       <h2>Koleksi dan penggunaan array</h2> 
       <p>Ketika Anda menggunakan array atau kelas dari ruang nama <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic?view=net-6.0"><code>System.Collection</code></a> (misalnya, Daftar atau Dictionaries), itu efisien untuk digunakan kembali atau kolam koleksi atau array yang dialokasikan. Kelas koleksi mengekspos metode yang jelas, yang menghilangkan nilai koleksi tetapi tidak melepaskan memori yang dialokasikan ke koleksi.</p> 
       <p>Ini berguna jika Anda ingin mengalokasikan koleksi “bantuer” sementara untuk komputasi kompleks. Contoh kode berikut menunjukkan ini:</p> 
       <pre><code class="lang-csharp">// Bad C# script example. This Update method allocates a new List every frame.
void Update() {

    List&lt;float&gt; nearestNeighbors = new List&lt;float&gt;();

    findDistancesToNearestNeighbors(nearestNeighbors);

    nearestNeighbors.Sort();

    // … use the sorted list somehow …
}
</code></pre> 
       <p>Contoh ini mengalokasikan daftar terdekatNeighbors sekali per frame untuk mengumpulkan satu set poin data.</p> 
       <p>Anda dapat mengangkat Daftar ini dari metode dan ke dalam kelas yang mengandung, sehingga kode Anda tidak perlu mengalokasikan Daftar baru setiap bingkai:</p> 
       <pre><code class="lang-csharp">// Good C# script example. This method re-uses the same List every frame.
List&lt;float&gt; m_NearestNeighbors = new List&lt;float&gt;();

void Update() {

    m_NearestNeighbors.Clear();

    findDistancesToNearestNeighbors(NearestNeighbors);

    m_NearestNeighbors.Sort();

    // … use the sorted list somehow …
}
</code></pre> 
       <p>Kode contoh ini mempertahankan dan menggunakan memori Daftar di beberapa bingkai. Kode hanya mengalokasikan memori baru ketika Daftar perlu diperluas.</p> 
       <p><a name="closures"></a></p> 
       <h2>Penutupan dan metode anonim</h2> 
       <p>Secara umum, Anda harus menghindari penutupan di C# setiap saat mungkin. Anda harus meminimalkan penggunaan metode anonim dan referensi metode dalam kode sensitif kinerja, dan terutama dalam kode yang mengeksekusi dasar per-frame.</p> 
       <p>Metode referensi dalam C # adalah jenis referensi, sehingga mereka dialokasikan pada tuju. Ini berarti bahwa jika Anda melewati referensi metode sebagai argumen, mudah untuk membuat alokasi sementara. Alokasi ini terjadi terlepas dari apakah metode yang Anda lewatkan adalah metode anonim atau yang ditentukan.</p> 
       <p>Juga, ketika Anda mengonversi metode anonim ke penutupan, jumlah memori yang diperlukan untuk melewati penutupan ke metode meningkatkan banyak.</p> 
       <p>Berikut ini sampel kode di mana daftar nomor acak harus diurutkan dalam urutan tertentu. Ini menggunakan metode anonim untuk mengontrol urutan penyortiran dari daftar, dan penyortiran tidak membuat alokasi.</p> 
       <pre><code class="lang-csharp">// Good C# script example: using an anonymous method to sort a list. 
// This sorting method doesn’t create garbage
List&lt;float&gt; listOfNumbers = getListOfRandomNumbers();


listOfNumbers.Sort( (x, y) =&gt;

(int)x.CompareTo((int)(y/2)) 

);
</code></pre> 
       <p>Untuk membuat cuplikan ini dapat digunakan kembali, Anda mungkin mengganti 2 konstan untuk variabel dalam lingkup lokal:</p> 
       <pre><code class="lang-csharp">// Bad C# script example: the anonymous method has become a closure,
// and now allocates memory to store the value of desiredDivisor
// every time it is called.
List&lt;float&gt; listOfNumbers = getListOfRandomNumbers();


int desiredDivisor = getDesiredDivisor();

listOfNumbers.Sort( (x, y) =&gt;

(int)x.CompareTo((int)(y/desiredDivisor))

);
</code></pre> 
       <p>Metode anonim sekarang perlu mengakses keadaan variabel yang berada di luar ruang lingkupnya, dan sehingga metode telah menjadi penutupan. Variabel <code>desiredDivisor</code> harus dilewatkan ke dalam penutupan sehingga kode penutupan dapat menggunakannya.</p> 
       <p>Untuk memastikan bahwa nilai yang benar dilewatkan pada penutupan, C# menghasilkan kelas anonim yang dapat mempertahankan variabel lingkup eksternal yang kebutuhan penutupan. Salinan kelas ini sesaat ketika penutupan dilewatkan ke metode Sort, dan salinan diinisialisasi dengan nilai integer Divisor yang diinginkan.</p> 
       <p>Mengeksekusi penutupan memerlukan instansi salinan kelas yang dihasilkan, dan semua kelas adalah jenis referensi dalam C #. Untuk alasan ini, mengeksekusi penutupan membutuhkan alokasi objek pada heap yang dikelola.</p> 
       <p><a name="boxing"></a></p> 
       <h2>Boxing</h2> 
       <p>Tinju adalah salah satu sumber yang paling umum dari alokasi memori sementara yang tidak diinginkan yang ditemukan di proyek Unity. Kebetulan ketika variabel bertipe nilai akan secara otomatis dikonversi ke tipe referensi. Ini paling sering terjadi ketika melewati variabel berjenis nilai primitif (seperti int dan float) ke metode berjenis objek. Anda harus menghindari tinju saat menulis kode C# untuk Unity.</p> 
       <p>Dalam contoh ini, integer di x kotak sehingga dapat dilewatkan ke metode <code>object.Equals</code>, karena metode <code>Equals</code> pada objek membutuhkan bahwa objek dilewatkan ke dalamnya.</p> 
       <pre><code class="lang-csharp">int x = 1;

object y = new object();

y.Equals(x);
</code></pre> 
       <p>C# IDE dan kompiler tidak mengeluarkan peringatan tentang tinju, meskipun tinju mengarah ke alokasi memori yang tidak diinginkan. Hal ini karena C# mengasumsikan bahwa alokasi sementara kecil efisien ditangani oleh kolektor garbage generasi dan kolam memori sensitif ukuran alokasi.</p> 
       <p>Meskipun allokator Unity tidak menggunakan kolam memori yang berbeda untuk alokasi kecil dan besar, <a href="performance-garbage-collector.md">kolektor sampah</a> Unity tidak generasi, sehingga tidak dapat menyapu secara efisien dari alokasi sementara kecil yang menghasilkan kotak.</p> 
       <h3>Mengidentifikasi tinju</h3> 
       <p>Tinju muncul di jejak CPU sebagai panggilan ke salah satu dari beberapa metode, tergantung pada ujung belakang scripting digunakan. Ini mengambil salah satu bentuk berikut, di mana <code>&lt;example class&gt;</code> adalah nama kelas atau merusak, dan <code>…</code> adalah sejumlah argumen:</p> 
       <pre><code class="lang-csharp">&lt;example class&gt;::Box(…)
Box(…)
&lt;example class&gt;_Box(…)
</code></pre> 
       <p>Untuk menemukan tinju, Anda juga dapat mencari output dari penampil atau pemirsa IL, seperti <a href="https://www.jetbrains.com/help/resharper/Viewing_Intermediate_Language.html">IL alat pemirsa yang dibangun ke ReSharper</a> atau <a href="https://www.jetbrains.com/decompiler/">dotPeek decompiler</a>. Instruksi IL adalah <code>box</code>.</p> 
       <p><a name="arrayapis"></a></p> 
       <h2>API Unity</h2> 
       <p>Penyebab halus dari array alokasi yang tidak diinginkan adalah akses berulang dari API Unity yang kembali array. Semua API Unity yang mengembalikan array menciptakan salinan baru dari array setiap kali mereka diakses. Jika kode Anda mengakses API Unity bernilai array lebih sering daripada yang diperlukan, kemungkinan akan menjadi dampak merugikan pada kinerja.</p> 
       <p>Sebagai contoh, kode berikut tidak perlu membuat empat salinan array vertices per iterasi loop. Alokasi terjadi setiap kali properti <code>.vertices</code> diakses.</p> 
       <pre><code class="lang-csharp">// Bad C# script example: this loop create 4 copies of the vertices array per iteration
void Update() {
    for(int i = 0; i &lt; mesh.vertices.Length; i++) {
        float x, y, z;

        x = mesh.vertices[i].x;
        y = mesh.vertices[i].y;
        z = mesh.vertices[i].z;

        // ...

        DoSomething(x, y, z);   
    }
}

</code></pre> 
       <p>Anda dapat mengisi ulang kode ini menjadi alokasi array tunggal, terlepas dari jumlah iterasi loop. Untuk melakukan ini, mengkonfigurasi kode Anda untuk menangkap array vertices sebelum loop:</p> 
       <pre><code class="lang-csharp">// Better C# script example: create one copy of the vertices array
// and work with that
void Update() {
    var vertices = mesh.vertices;

    for(int i = 0; i &lt; vertices.Length; i++) {

        float x, y, z;

        x = vertices[i].x;
        y = vertices[i].y;
        z = vertices[i].z;

        // ...

        DoSomething(x, y, z);   
    }
}
</code></pre> 
       <p>Cara yang lebih baik untuk melakukan ini adalah untuk mempertahankan Daftar vertik yang cache dan digunakan kembali antara bingkai, dan kemudian gunakan <a href="../ScriptReference/Mesh.GetVertices.html">Mesh.GetVertices</a> untuk mengisinya ketika diperlukan.</p> 
       <pre><code class="lang-csharp">// Best C# script example: create one copy of the vertices array
// and work with that.
List&lt;Vector3&gt; m_vertices = new List&lt;Vector3&gt;();

void Update() {
    mesh.GetVertices(m_vertices);

    for(int i = 0; i &lt; m_vertices.Length; i++) {

        float x, y, z;

        x = m_vertices[i].x;
        y = m_vertices[i].y;
        z = m_vertices[i].z;

        // ...

        DoSomething(x, y, z);   
    }
}
</code></pre> 
       <p>Sementara implikasi kinerja CPU mengakses properti sekali tidak tinggi, akses berulang dalam loop ketat menciptakan hotspot kinerja CPU. Akses berulang memperluas <a href="performance-managed-memory.html#managed-heap">managed heap</a>.</p> 
       <p>Masalah ini umum pada perangkat mobile, karena API <a href="../ScriptReference/Input-touches.html">Input.touches</a> berperilaku mirip dengan di atas. Ini juga umum untuk proyek untuk mengandung kode yang mirip dengan berikut, di mana alokasi terjadi setiap kali properti <code>.touches</code> diakses.</p> 
       <pre><code class="lang-csharp">// Bad C# script example: Input.touches returns an array every time it’s accessed
for ( int i = 0; i &lt; Input.touches.Length; i++ ) {
   Touch touch = Input.touches[i];

    // …
}
</code></pre> 
       <p>Untuk meningkatkan ini, Anda dapat mengkonfigurasi kode Anda untuk mengangkat alokasi array dari kondisi loop:</p> 
       <pre><code class="lang-csharp">// Better C# script example: Input.touches is only accessed once here
Touch[] touches = Input.touches;

for ( int i = 0; i &lt; touches.Length; i++ ) {

   Touch touch = touches[i];

   // …
}
</code></pre> 
       <p>Contoh kode berikut mengkonversi contoh sebelumnya ke API Sentuh bebas alokasi:</p> 
       <pre><code class="lang-csharp">// BEST C# script example: Input.touchCount and Input.GetTouch don’t allocate at all.
int touchCount = Input.touchCount;

for ( int i = 0; i &lt; touchCount; i++ ) {
   Touch touch = Input.GetTouch(i);

   // …
}
</code></pre> 
       <p>Sitemap Akses properti (<strong>Note:</strong>) tetap berada di luar kondisi lingkaran, untuk menghemat dampak CPU untuk memanggil metode mendapatkan properti.<code>Input.touchCount</code>) remains outside the loop condition, to save the CPU impact of invoking the property’s get method.</p> 
       <h3>Alternatif non-allocating API</h3> 
       <p>Beberapa Unity API memiliki versi alternatif yang tidak menyebabkan alokasi memori. Anda harus menggunakan ini ketika mungkin. Meme it Tabel berikut menunjukkan pilihan kecil dari API allokating umum dan alternatif non-penemuan mereka. Daftar tidak knalpot, tetapi harus menunjukkan jenis API untuk menonton.</p> 
       <table> 
        <colgroup> 
         <col style="text-align:left;"> 
         <col style="text-align:left;"> 
        </colgroup> 
        <thead> 
         <tr> 
          <th style="text-align:left;"><strong>Allocating API</strong></th> 
          <th style="text-align:left;"><strong>Non-allocating API alternative</strong></th> 
         </tr> 
        </thead> 
        <tbody> 
         <tr> 
          <td style="text-align:left;"><a href="../ScriptReference/Physics.RaycastAll.html">Fisika.RaycastSemua</a></td> 
          <td style="text-align:left;"><a href="../ScriptReference/Physics.RaycastNonAlloc.html">Fisika.RaycastNonAlloc</a></td> 
         </tr> 
         <tr> 
          <td style="text-align:left;"><a href="../ScriptReference/Animator-parameters.html">Animator.parameter</a></td> 
          <td style="text-align:left;"> <a href="../ScriptReference/Animator-parameterCount.html">Animator.parameterCount</a> dan <a href="../ScriptReference/Animator.GetParameter.html">Animator.GetParameter</a> </td> 
         </tr> 
         <tr> 
          <td style="text-align:left;"><a href="../ScriptReference/Renderer-sharedMaterials.html">Renderer.sharedMaterials</a></td> 
          <td style="text-align:left;"><a href="../ScriptReference/Renderer.GetSharedMaterials.html">Renderer.GetSharedMaterials</a></td> 
         </tr> 
        </tbody> 
       </table> 
       <p><a name="emptyarray"></a></p> 
       <h2>Reuse array kosong</h2> 
       <p>Beberapa tim pengembangan lebih memilih untuk mengembalikan array kosong daripada null ketika metode nilai array perlu mengembalikan set kosong. Pola pengkodean ini umum dalam banyak bahasa yang dikelola, terutama C# dan Java.</p> 
       <p>Secara umum, ketika mengembalikan array nol dari metode, lebih efisien untuk mengembalikan instance statis pra-dilokasi dari array nol-panjang daripada berulang kali menciptakan array kosong.</p> 
       <h2>Sumber daya</h2> 
       <ul> 
        <li><a href="performance-garbage-collector.html">Gambaran keseluruhan kolektor sampah</a></li> 
        <li><a href="performance-managed-memory.html">Gambaran keseluruhan memori yang terkelola</a></li> 
        <li><a href="performance-incremental-garbage-collection.html">Pengumpulan sampah</a></li> 
       </ul> 
       <div id="_content"></div> 
       <div class="nextprev clear"> 
        <div class="icon tt left mr1" data-distance="-40|-30|top"> 
         <span class="prev"><a href="performance-disabling-garbage-collection.html"></a></span> 
         <div class="tip">
           Mengaktifkan koleksi sampah 
         </div> 
        </div> 
        <div class="icon tt right" data-distance="-40|-30|top"> 
         <span class="next"><a href="Profiler.html"></a></span> 
         <div class="tip">
           Profiler 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="footer-wrapper"> 
       <div class="footer clear"> 
        <div class="copy">
          © 2022 Unity Technologies. Tanggal Publikasi: 2022-04-04. 
        </div> 
        <div class="menu"> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div>  
 </body>
</html>